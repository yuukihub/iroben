// node_modules/onsenui/esm/ons/platform.js
var NativeHTMLElement = window.HTMLElement;
var Platform = class {
  /**
   * All elements will be rendered as if the app was running on this platform.
   * @type {String}
   */
  constructor() {
    this._selectedPlatform = null;
    this._ignorePlatformSelect = false;
  }
  /**
   * @method select
   * @signature select(platform)
   * @param  {string} platform Name of the platform.
   *   [en]Possible values are: "opera", "firefox", "safari", "chrome", "ie", "android", "blackberry", "ios" or "wp".[/en]
   *   [ja]"opera", "firefox", "safari", "chrome", "ie", "android", "blackberry", "ios", "wp"のいずれかを指定します。[/ja]
   * @description
   *   [en]Sets the platform used to render the elements. Useful for testing.[/en]
   *   [ja]要素を描画するために利用するプラットフォーム名を設定します。テストに便利です。[/ja]
   */
  select(platform) {
    if (typeof platform === "string") {
      this._selectedPlatform = platform.trim().toLowerCase();
    }
  }
  _getSelectedPlatform() {
    return this._ignorePlatformSelect ? null : this._selectedPlatform;
  }
  _runOnActualPlatform(fn) {
    this._ignorePlatformSelect = true;
    const result = fn();
    this._ignorePlatformSelect = false;
    return result;
  }
  //----------------
  // General
  //----------------
  /**
   * @method isWebView
   * @signature isWebView()
   * @description
   *   [en]Returns whether app is running in Cordova.[/en]
   *   [ja]Cordova内で実行されているかどうかを返します。[/ja]
   * @return {Boolean}
   */
  isWebView() {
    if (document.readyState === "loading" || document.readyState == "uninitialized") {
      throw new Error("isWebView() method is available after dom contents loaded.");
    }
    return !!(window.cordova || window.phonegap || window.PhoneGap);
  }
  //----------------
  // iOS devices
  //----------------
  /**
   * @method isIPhone
   * @signature isIPhone()
   * @description
   *   [en]Returns whether the device is iPhone.[/en]
   *   [ja]iPhone上で実行されているかどうかを返します。[/ja]
   * @return {Boolean}
   */
  isIPhone() {
    return /iPhone/i.test(navigator.userAgent);
  }
  /**
   * @method isIPhoneX
   * @signature isIPhoneX()
   * @description
   *   [en]Returns whether the device is iPhone X, XS, XS Max, XR, 11, 11 Pro, 11 Pro Max, 12 Mini, 12, 12 Pro or 12 Pro Max, 13 Mini, 13, 13 Pro, 13 Pro Max, 14, 14 Plus, 14 Pro, 14 Pro Max.[/en]
   *   [ja]iPhone X や XS、XS Max、XR、11、11 Pro、11 Pro Max、12 Mini、12、12 Pro、12 Pro Max、13 Mini、13、13 Pro、13 Pro Max、14、14 Plus、14 Pro、または14 Pro Max上で実行されているかどうかを返します。[/ja]
   * @return {Boolean}
   */
  isIPhoneX() {
    return this.isIPhone() && // X, XS, 11 Pro, 12 Mini, 13 Mini
    (window.screen.width === 375 && window.screen.height === 812 || // portrait
    window.screen.width === 812 && window.screen.height === 375 || // landscape
    // XS Max, XR, 11, 11 Pro Max
    window.screen.width === 414 && window.screen.height === 896 || // portrait
    window.screen.width === 896 && window.screen.height === 414 || // landscape
    // 12, 12 Pro, 13, 13 Pro, 14
    window.screen.width === 390 && window.screen.height === 844 || // portrait
    window.screen.width === 844 && window.screen.height === 390 || // landscape
    // 12 Pro Max, 13 Pro Max, 14 Plus
    window.screen.width === 428 && window.screen.height === 926 || // portrait
    window.screen.width === 926 && window.screen.height === 428 || // landscape
    // 14 Pro Max
    window.screen.width === 430 && window.screen.height === 932 || // portrait
    window.screen.width === 932 && window.screen.height === 430 || // landscape
    // 14 Pro
    window.screen.width === 393 && window.screen.height === 852 || // portrait
    window.screen.width === 852 && window.screen.height === 393);
  }
  /**
   * @method isIPad
   * @signature isIPad()
   * @description
   *   [en]Returns whether the device is iPad.[/en]
   *   [ja]iPad上で実行されているかどうかを返します。[/ja]
   * @return {Boolean}
   */
  isIPad() {
    return /iPad/i.test(navigator.userAgent) || this.isIPadOS();
  }
  /**
   * @return {Boolean}
   */
  isIPod() {
    return /iPod/i.test(navigator.userAgent);
  }
  //----------------
  // iOS versions
  //----------------
  /**
   * @method isIOS
   * @signature isIOS([forceActualPlatform])
   * @param {Boolean} forceActualPlatform
   *   [en]If true, selected platform is ignored and the actual platform is returned.[/en]
   *   [ja][/ja]
   * @description
   *   [en]Returns whether the OS is iOS. By default will return manually selected platform if it is set.[/en]
   *   [ja]iOS上で実行されているかどうかを返します。[/ja]
   * @return {Boolean}
   */
  isIOS(forceActualPlatform) {
    if (!forceActualPlatform && this._getSelectedPlatform()) {
      return this._getSelectedPlatform() === "ios";
    }
    if (typeof device === "object" && !/browser/i.test(device.platform)) {
      return /iOS/i.test(device.platform);
    } else {
      return /iPhone|iPad|iPod/i.test(navigator.userAgent) || this.isIPadOS();
    }
  }
  /**
   * @method isIOS7above
   * @signature isIOS7above()
   * @description
   *   [en]Returns whether the iOS version is 7 or above.[/en]
   *   [ja]iOS7以上で実行されているかどうかを返します。[/ja]
   * @return {Boolean}
   */
  isIOS7above() {
    if (typeof device === "object" && !/browser/i.test(device.platform)) {
      return /iOS/i.test(device.platform) && parseInt(device.version.split(".")[0]) >= 7;
    } else if (/iPhone|iPad|iPod/i.test(navigator.userAgent)) {
      const ver = (navigator.userAgent.match(/\b[0-9]+_[0-9]+(?:_[0-9]+)?\b/) || [""])[0].replace(/_/g, ".");
      return parseInt(ver.split(".")[0]) >= 7;
    }
    return false;
  }
  /**
   * @method isIPadOS
   * @signature isIPadOS()
   * @description
   *   [en]Returns whether the OS is iPadOS.[/en]
   *   [ja][/ja]
   * @return {Boolean}
   */
  isIPadOS() {
    return !!(/Macintosh/i.test(navigator.userAgent) && navigator.maxTouchPoints && navigator.maxTouchPoints === 5);
  }
  //----------------
  // iOS browsers
  //----------------
  /**
   * @method isIOSSafari
   * @signature isIOSSafari()
   * @description
   *   [en]Returns whether app is running in iOS Safari.[/en]
   *   [ja]iOS Safariで実行されているかどうかを返します。[/ja]
   * @return {Boolean}
   */
  isIOSSafari() {
    const navigator2 = window.navigator;
    const ua = navigator2.userAgent;
    return !!(this.isIOS() && ua.indexOf("Safari") !== -1 && ua.indexOf("Version") !== -1 && !navigator2.standalone);
  }
  /**
   * @method isWKWebView
   * @signature isWKWebView()
   * @description
   *   [en]Returns whether app is running in WKWebView.[/en]
   *   [ja]WKWebViewで実行されているかどうかを返します。[/ja]
   * @return {Boolean}
   */
  isWKWebView() {
    const lte9 = /constructor/i.test(NativeHTMLElement);
    return !!(this.isIOS() && window.webkit && window.webkit.messageHandlers && window.indexedDB && !lte9);
  }
  //----------------
  // Android devices
  //----------------
  /**
   * @method isAndroidPhone
   * @signature isAndroidPhone()
   * @description
   *   [en]Returns whether the device is Android phone.[/en]
   *   [ja]Android携帯上で実行されているかどうかを返します。[/ja]
   * @return {Boolean}
   */
  isAndroidPhone() {
    return /Android/i.test(navigator.userAgent) && /Mobile/i.test(navigator.userAgent);
  }
  /**
   * @method isAndroidTablet
   * @signature isAndroidTablet()
   * @description
   *   [en]Returns whether the device is Android tablet.[/en]
   *   [ja]Androidタブレット上で実行されているかどうかを返します。[/ja]
   * @return {Boolean}
   */
  isAndroidTablet() {
    return /Android/i.test(navigator.userAgent) && !/Mobile/i.test(navigator.userAgent);
  }
  //----------------
  // Android versions
  //----------------
  /**
   * @method isAndroid
   * @signature isAndroid([forceActualPlatform])
   * @param {Boolean} forceActualPlatform
   *   [en]If true, selected platform is ignored and the actual platform is returned.[/en]
   *   [ja][/ja]
   * @description
   *   [en]Returns whether the OS is Android. By default will return manually selected platform if it is set.[/en]
   *   [ja]Android上で実行されているかどうかを返します。[/ja]
   * @return {Boolean}
   */
  isAndroid(forceActualPlatform) {
    if (!forceActualPlatform && this._getSelectedPlatform()) {
      return this._getSelectedPlatform() === "android";
    }
    if (typeof device === "object" && !/browser/i.test(device.platform)) {
      return /Android/i.test(device.platform);
    } else {
      return /Android/i.test(navigator.userAgent);
    }
  }
  //----------------
  // Other devices
  //----------------
  /**
   * @method isWP
   * @signature isWP([forceActualPlatform])
   * @param {Boolean} forceActualPlatform
   *   [en]If true, selected platform is ignored and the actual platform is returned.[/en]
   *   [ja][/ja]
   * @description
   *   [en]Returns whether the OS is Windows phone. By default will return manually selected platform if it is set.[/en]
   *   [ja][/ja]
   * @return {Boolean}
   */
  isWP(forceActualPlatform) {
    if (!forceActualPlatform && this._getSelectedPlatform()) {
      return this._getSelectedPlatform() === "wp";
    }
    if (typeof device === "object" && !/browser/i.test(device.platform)) {
      return /Win32NT|WinCE/i.test(device.platform);
    } else {
      return /Windows Phone|IEMobile|WPDesktop/i.test(navigator.userAgent);
    }
  }
  /**
   * @method isBlackBerry
   * @signature isBlackBerry([forceActualPlatform])
   * @param {Boolean} forceActualPlatform
   *   [en]If true, selected platform is ignored and the actual platform is returned.[/en]
   *   [ja][/ja]
   * @description
   *   [en]Returns whether the device is BlackBerry. By default will return manually selected platform if it is set.[/en]
   *   [ja]BlackBerry上で実行されているかどうかを返します。[/ja]
   * @return {Boolean}
   */
  isBlackBerry(forceActualPlatform) {
    if (!forceActualPlatform && this._getSelectedPlatform()) {
      return this._getSelectedPlatform() === "blackberry";
    }
    if (typeof device === "object" && !/browser/i.test(device.platform)) {
      return /BlackBerry/i.test(device.platform);
    } else {
      return /BlackBerry|RIM Tablet OS|BB10/i.test(navigator.userAgent);
    }
  }
  //----------------
  // Other browsers
  //----------------
  /**
   * @method isOpera
   * @signature isOpera([forceActualPlatform])
   * @param {Boolean} forceActualPlatform
   *   [en]If true, selected platform is ignored and the actual platform is returned.[/en]
   *   [ja][/ja]
   * @description
   *   [en]Returns whether the browser is Opera. By default will return manually selected platform if it is set.[/en]
   *   [ja]Opera上で実行されているかどうかを返します。[/ja]
   * @return {Boolean}
   */
  isOpera(forceActualPlatform) {
    if (!forceActualPlatform && this._getSelectedPlatform()) {
      return this._getSelectedPlatform() === "opera";
    }
    return !!window.opera || navigator.userAgent.indexOf(" OPR/") >= 0;
  }
  /**
   * @method isFirefox
   * @signature isFirefox([forceActualPlatform])
   * @param {Boolean} forceActualPlatform
   *   [en]If true, selected platform is ignored and the actual platform is returned.[/en]
   *   [ja][/ja]
   * @description
   *   [en]Returns whether the browser is Firefox. By default will return manually selected platform if it is set.[/en]
   *   [ja]Firefox上で実行されているかどうかを返します。[/ja]
   * @return {Boolean}
   */
  isFirefox(forceActualPlatform) {
    if (!forceActualPlatform && this._getSelectedPlatform()) {
      return this._getSelectedPlatform() === "firefox";
    }
    return typeof InstallTrigger !== "undefined";
  }
  /**
   * @method isSafari
   * @signature isSafari([forceActualPlatform])
   * @param {Boolean} forceActualPlatform
   *   [en]If true, selected platform is ignored and the actual platform is returned.[/en]
   *   [ja][/ja]
   * @description
   *   [en]Returns whether the browser is Safari. By default will return manually selected platform if it is set.[/en]
   *   [ja]Safari上で実行されているかどうかを返します。[/ja]
   * @return {Boolean}
   */
  isSafari(forceActualPlatform) {
    if (!forceActualPlatform && this._getSelectedPlatform()) {
      return this._getSelectedPlatform() === "safari";
    }
    return Object.prototype.toString.call(window.HTMLElement).indexOf("Constructor") > 0 || function(p) {
      return p.toString() === "[object SafariRemoteNotification]";
    }(!window["safari"] || safari.pushNotification);
  }
  /**
   * @method isChrome
   * @signature isChrome([forceActualPlatform])
   * @param {Boolean} forceActualPlatform
   *   [en]If true, selected platform is ignored and the actual platform is returned.[/en]
   *   [ja][/ja]
   * @description
   *   [en]Returns whether the browser is Chrome. By default will return manually selected platform if it is set.[/en]
   *   [ja]Chrome上で実行されているかどうかを返します。[/ja]
   * @return {Boolean}
   */
  isChrome(forceActualPlatform) {
    if (!forceActualPlatform && this._getSelectedPlatform()) {
      return this._getSelectedPlatform() === "chrome";
    }
    return !!window.chrome && !(!!window.opera || navigator.userAgent.indexOf(" OPR/") >= 0) && !(navigator.userAgent.indexOf(" Edge/") >= 0);
  }
  /**
   * @method isIE
   * @signature isIE([forceActualPlatform])
   * @param {Boolean} forceActualPlatform
   *   [en]If true, selected platform is ignored and the actual platform is returned.[/en]
   *   [ja][/ja]
   * @description
   *   [en]Returns whether the browser is Internet Explorer. By default will return manually selected platform if it is set.[/en]
   *   [ja]Internet Explorer上で実行されているかどうかを返します。[/ja]
   * @return {Boolean}
   */
  isIE(forceActualPlatform) {
    if (!forceActualPlatform && this._getSelectedPlatform()) {
      return this._getSelectedPlatform() === "ie";
    }
    return !!document.documentMode;
  }
  /**
   * @method isEdge
   * @signature isEdge([forceActualPlatform])
   * @param {Boolean} forceActualPlatform
   *   [en]If true, selected platform is ignored and the actual platform is returned.[/en]
   *   [ja][/ja]
   * @description
   *   [en]Returns whether the browser is Edge. By default will return manually selected platform if it is set.[/en]
   *   [ja]Edge上で実行されているかどうかを返します。[/ja]
   * @return {Boolean}
   */
  isEdge(forceActualPlatform) {
    if (!forceActualPlatform && this._getSelectedPlatform()) {
      return this._getSelectedPlatform() === "edge";
    }
    return navigator.userAgent.indexOf(" Edge/") >= 0;
  }
  //----------------
  // Utility functions
  //----------------
  /**
   * @return {String}
   */
  getMobileOS() {
    if (this.isAndroid()) {
      return "android";
    } else if (this.isIOS()) {
      return "ios";
    } else if (this.isWP()) {
      return "wp";
    } else {
      return "other";
    }
  }
  /**
   * @return {String}
   */
  getIOSDevice() {
    if (this.isIPhone()) {
      return "iphone";
    } else if (this.isIPad()) {
      return "ipad";
    } else if (this.isIPod()) {
      return "ipod";
    } else {
      return "na";
    }
  }
};
var platform_default = new Platform();

// node_modules/onsenui/esm/polyfills/polyfill-switches.js
if (window.customElements) {
  window.customElements.forcePolyfill = true;
}

// node_modules/onsenui/esm/polyfills/custom-elements/custom-elements.min.js
(function() {
  "use strict";
  var g = new function() {
  }();
  var aa = new Set("annotation-xml color-profile font-face font-face-src font-face-uri font-face-format font-face-name missing-glyph".split(" "));
  function k(b) {
    var a = aa.has(b);
    b = /^[a-z][.0-9_a-z]*-[\-.0-9_a-z]*$/.test(b);
    return !a && b;
  }
  function l(b) {
    var a = b.isConnected;
    if (void 0 !== a)
      return a;
    for (; b && !(b.__CE_isImportDocument || b instanceof Document); )
      b = b.parentNode || (window.ShadowRoot && b instanceof ShadowRoot ? b.host : void 0);
    return !(!b || !(b.__CE_isImportDocument || b instanceof Document));
  }
  function m(b, a) {
    for (; a && a !== b && !a.nextSibling; )
      a = a.parentNode;
    return a && a !== b ? a.nextSibling : null;
  }
  function n(b, a, e) {
    e = e ? e : /* @__PURE__ */ new Set();
    for (var c = b; c; ) {
      if (c.nodeType === Node.ELEMENT_NODE) {
        var d = c;
        a(d);
        var h = d.localName;
        if ("link" === h && "import" === d.getAttribute("rel")) {
          c = d.import;
          if (c instanceof Node && !e.has(c))
            for (e.add(c), c = c.firstChild; c; c = c.nextSibling)
              n(c, a, e);
          c = m(b, d);
          continue;
        } else if ("template" === h) {
          c = m(b, d);
          continue;
        }
        if (d = d.__CE_shadowRoot)
          for (d = d.firstChild; d; d = d.nextSibling)
            n(d, a, e);
      }
      c = c.firstChild ? c.firstChild : m(b, c);
    }
  }
  function q(b, a, e) {
    b[a] = e;
  }
  ;
  function r() {
    this.a = /* @__PURE__ */ new Map();
    this.f = /* @__PURE__ */ new Map();
    this.c = [];
    this.b = false;
  }
  function ba(b, a, e) {
    b.a.set(a, e);
    b.f.set(e.constructor, e);
  }
  function t(b, a) {
    b.b = true;
    b.c.push(a);
  }
  function v(b, a) {
    b.b && n(a, function(a2) {
      return w(b, a2);
    });
  }
  function w(b, a) {
    if (b.b && !a.__CE_patched) {
      a.__CE_patched = true;
      for (var e = 0; e < b.c.length; e++)
        b.c[e](a);
    }
  }
  function x(b, a) {
    var e = [];
    n(a, function(b2) {
      return e.push(b2);
    });
    for (a = 0; a < e.length; a++) {
      var c = e[a];
      1 === c.__CE_state ? l(c) && b.connectedCallback(c) : y(b, c);
    }
  }
  function z(b, a) {
    var e = [];
    n(a, function(b2) {
      return e.push(b2);
    });
    for (a = 0; a < e.length; a++) {
      var c = e[a];
      1 === c.__CE_state && b.disconnectedCallback(c);
    }
  }
  function A(b, a, e) {
    e = e ? e : /* @__PURE__ */ new Set();
    var c = [];
    n(a, function(d) {
      if ("link" === d.localName && "import" === d.getAttribute("rel")) {
        var a2 = d.import;
        a2 instanceof Node && "complete" === a2.readyState ? (a2.__CE_isImportDocument = true, a2.__CE_hasRegistry = true) : d.addEventListener("load", function() {
          var a3 = d.import;
          a3.__CE_documentLoadHandled || (a3.__CE_documentLoadHandled = true, a3.__CE_isImportDocument = true, a3.__CE_hasRegistry = true, new Set(e), e.delete(a3), A(b, a3, e));
        });
      } else
        c.push(d);
    }, e);
    if (b.b)
      for (a = 0; a < c.length; a++)
        w(b, c[a]);
    for (a = 0; a < c.length; a++)
      y(
        b,
        c[a]
      );
  }
  function y(b, a) {
    if (void 0 === a.__CE_state) {
      var e = b.a.get(a.localName);
      if (e) {
        e.constructionStack.push(a);
        var c = e.constructor;
        try {
          try {
            if (new c() !== a)
              throw Error("The custom element constructor did not produce the element being upgraded.");
          } finally {
            e.constructionStack.pop();
          }
        } catch (f) {
          throw a.__CE_state = 2, f;
        }
        a.__CE_state = 1;
        a.__CE_definition = e;
        if (e.attributeChangedCallback)
          for (e = e.observedAttributes, c = 0; c < e.length; c++) {
            var d = e[c], h = a.getAttribute(d);
            null !== h && b.attributeChangedCallback(a, d, null, h, null);
          }
        l(a) && b.connectedCallback(a);
      }
    }
  }
  r.prototype.connectedCallback = function(b) {
    var a = b.__CE_definition;
    a.connectedCallback && a.connectedCallback.call(b);
    b.i = true;
  };
  r.prototype.disconnectedCallback = function(b) {
    b.i || this.connectedCallback(b);
    var a = b.__CE_definition;
    a.disconnectedCallback && a.disconnectedCallback.call(b);
    b.i = void 0;
  };
  r.prototype.attributeChangedCallback = function(b, a, e, c, d) {
    var h = b.__CE_definition;
    h.attributeChangedCallback && -1 < h.observedAttributes.indexOf(a) && h.attributeChangedCallback.call(b, a, e, c, d);
  };
  function B(b, a) {
    this.c = b;
    this.a = a;
    this.b = void 0;
    A(this.c, this.a);
    "loading" === this.a.readyState && (this.b = new MutationObserver(this.f.bind(this)), this.b.observe(this.a, { childList: true, subtree: true }));
  }
  function C(b) {
    b.b && b.b.disconnect();
  }
  B.prototype.f = function(b) {
    var a = this.a.readyState;
    "interactive" !== a && "complete" !== a || C(this);
    for (a = 0; a < b.length; a++)
      for (var e = b[a].addedNodes, c = 0; c < e.length; c++)
        A(this.c, e[c]);
  };
  function ca() {
    var b = this;
    this.b = this.a = void 0;
    this.c = new Promise(function(a) {
      b.b = a;
      b.a && a(b.a);
    });
  }
  function D(b) {
    if (b.a)
      throw Error("Already resolved.");
    b.a = void 0;
    b.b && b.b(void 0);
  }
  ;
  function E(b) {
    this.f = false;
    this.a = b;
    this.h = /* @__PURE__ */ new Map();
    this.g = function(b2) {
      return b2();
    };
    this.b = false;
    this.c = [];
    this.l = new B(b, document);
  }
  E.prototype.m = function(b, a) {
    var e = this;
    if (!(a instanceof Function))
      throw new TypeError("Custom element constructors must be functions.");
    if (!k(b))
      throw new SyntaxError("The element name '" + b + "' is not valid.");
    if (this.a.a.get(b))
      throw Error("A custom element with name '" + b + "' has already been defined.");
    if (this.f)
      throw Error("A custom element is already being defined.");
    this.f = true;
    var c, d, h, f, u;
    try {
      var p = function(b2) {
        var a2 = P[b2];
        if (void 0 !== a2 && !(a2 instanceof Function))
          throw Error("The '" + b2 + "' callback must be a function.");
        return a2;
      }, P = a.prototype;
      if (!(P instanceof Object))
        throw new TypeError("The custom element constructor's prototype is not an object.");
      c = p("connectedCallback");
      d = p("disconnectedCallback");
      h = p("adoptedCallback");
      f = p("attributeChangedCallback");
      u = a.observedAttributes || [];
    } catch (va) {
      return;
    } finally {
      this.f = false;
    }
    ba(this.a, b, { localName: b, constructor: a, connectedCallback: c, disconnectedCallback: d, adoptedCallback: h, attributeChangedCallback: f, observedAttributes: u, constructionStack: [] });
    this.c.push(b);
    this.b || (this.b = true, this.g(function() {
      if (false !== e.b)
        for (e.b = false, A(e.a, document); 0 < e.c.length; ) {
          var b2 = e.c.shift();
          (b2 = e.h.get(b2)) && D(b2);
        }
    }));
  };
  E.prototype.get = function(b) {
    if (b = this.a.a.get(b))
      return b.constructor;
  };
  E.prototype.s = function(b) {
    if (!k(b))
      return Promise.reject(new SyntaxError("'" + b + "' is not a valid custom element name."));
    var a = this.h.get(b);
    if (a)
      return a.c;
    a = new ca();
    this.h.set(b, a);
    this.a.a.get(b) && -1 === this.c.indexOf(b) && D(a);
    return a.c;
  };
  E.prototype.o = function(b) {
    C(this.l);
    var a = this.g;
    this.g = function(e) {
      return b(function() {
        return a(e);
      });
    };
  };
  window.CustomElementRegistry = E;
  E.prototype.define = E.prototype.m;
  E.prototype.get = E.prototype.get;
  E.prototype.whenDefined = E.prototype.s;
  E.prototype.polyfillWrapFlushCallback = E.prototype.o;
  var F = window.Document.prototype.createElement, da = window.Document.prototype.createElementNS, ea = window.Document.prototype.importNode, fa = window.Document.prototype.prepend, ga = window.Document.prototype.append, G = window.Node.prototype.cloneNode, H = window.Node.prototype.appendChild, I = window.Node.prototype.insertBefore, J = window.Node.prototype.removeChild, K = window.Node.prototype.replaceChild, L = Object.getOwnPropertyDescriptor(window.Node.prototype, "textContent"), M = window.Element.prototype.attachShadow, N = Object.getOwnPropertyDescriptor(
    window.Element.prototype,
    "innerHTML"
  ), O = window.Element.prototype.getAttribute, Q = window.Element.prototype.setAttribute, R = window.Element.prototype.removeAttribute, S = window.Element.prototype.getAttributeNS, T = window.Element.prototype.setAttributeNS, U = window.Element.prototype.removeAttributeNS, V = window.Element.prototype.insertAdjacentElement, ha = window.Element.prototype.prepend, ia = window.Element.prototype.append, ja = window.Element.prototype.before, ka = window.Element.prototype.after, la = window.Element.prototype.replaceWith, ma = window.Element.prototype.remove, na = window.HTMLElement, W = Object.getOwnPropertyDescriptor(window.HTMLElement.prototype, "innerHTML"), X = window.HTMLElement.prototype.insertAdjacentElement;
  function oa() {
    var b = Y;
    window.HTMLElement = function() {
      function a() {
        var a2 = this.constructor, c = b.f.get(a2);
        if (!c)
          throw Error("The custom element being constructed was not registered with `customElements`.");
        var d = c.constructionStack;
        if (!d.length)
          return d = F.call(document, c.localName), Object.setPrototypeOf(d, a2.prototype), d.__CE_state = 1, d.__CE_definition = c, w(b, d), d;
        var c = d.length - 1, h = d[c];
        if (h === g)
          throw Error("The HTMLElement constructor was either called reentrantly for this constructor or called multiple times.");
        d[c] = g;
        Object.setPrototypeOf(h, a2.prototype);
        w(b, h);
        return h;
      }
      a.prototype = na.prototype;
      return a;
    }();
  }
  ;
  function pa(b, a, e) {
    a.prepend = function(a2) {
      for (var d = [], c = 0; c < arguments.length; ++c)
        d[c - 0] = arguments[c];
      c = d.filter(function(b2) {
        return b2 instanceof Node && l(b2);
      });
      e.j.apply(this, d);
      for (var f = 0; f < c.length; f++)
        z(b, c[f]);
      if (l(this))
        for (c = 0; c < d.length; c++)
          f = d[c], f instanceof Element && x(b, f);
    };
    a.append = function(a2) {
      for (var d = [], c = 0; c < arguments.length; ++c)
        d[c - 0] = arguments[c];
      c = d.filter(function(b2) {
        return b2 instanceof Node && l(b2);
      });
      e.append.apply(this, d);
      for (var f = 0; f < c.length; f++)
        z(b, c[f]);
      if (l(this))
        for (c = 0; c < d.length; c++)
          f = d[c], f instanceof Element && x(b, f);
    };
  }
  ;
  function qa() {
    var b = Y;
    q(Document.prototype, "createElement", function(a) {
      if (this.__CE_hasRegistry) {
        var e = b.a.get(a);
        if (e)
          return new e.constructor();
      }
      a = F.call(this, a);
      w(b, a);
      return a;
    });
    q(Document.prototype, "importNode", function(a, e) {
      a = ea.call(this, a, e);
      this.__CE_hasRegistry ? A(b, a) : v(b, a);
      return a;
    });
    q(Document.prototype, "createElementNS", function(a, e) {
      if (this.__CE_hasRegistry && (null === a || "http://www.w3.org/1999/xhtml" === a)) {
        var c = b.a.get(e);
        if (c)
          return new c.constructor();
      }
      a = da.call(this, a, e);
      w(b, a);
      return a;
    });
    pa(b, Document.prototype, { j: fa, append: ga });
  }
  ;
  function ra() {
    var b = Y;
    function a(a2, c) {
      Object.defineProperty(a2, "textContent", { enumerable: c.enumerable, configurable: true, get: c.get, set: function(a3) {
        if (this.nodeType === Node.TEXT_NODE)
          c.set.call(this, a3);
        else {
          var d = void 0;
          if (this.firstChild) {
            var e = this.childNodes, u = e.length;
            if (0 < u && l(this))
              for (var d = Array(u), p = 0; p < u; p++)
                d[p] = e[p];
          }
          c.set.call(this, a3);
          if (d)
            for (a3 = 0; a3 < d.length; a3++)
              z(b, d[a3]);
        }
      } });
    }
    q(Node.prototype, "insertBefore", function(a2, c) {
      if (a2 instanceof DocumentFragment) {
        var d = Array.prototype.slice.apply(a2.childNodes);
        a2 = I.call(this, a2, c);
        if (l(this))
          for (c = 0; c < d.length; c++)
            x(b, d[c]);
        return a2;
      }
      d = l(a2);
      c = I.call(this, a2, c);
      d && z(b, a2);
      l(this) && x(b, a2);
      return c;
    });
    q(Node.prototype, "appendChild", function(a2) {
      if (a2 instanceof DocumentFragment) {
        var c = Array.prototype.slice.apply(a2.childNodes);
        a2 = H.call(this, a2);
        if (l(this))
          for (var d = 0; d < c.length; d++)
            x(b, c[d]);
        return a2;
      }
      c = l(a2);
      d = H.call(this, a2);
      c && z(b, a2);
      l(this) && x(b, a2);
      return d;
    });
    q(Node.prototype, "cloneNode", function(a2) {
      a2 = G.call(this, a2);
      this.ownerDocument.__CE_hasRegistry ? A(b, a2) : v(b, a2);
      return a2;
    });
    q(Node.prototype, "removeChild", function(a2) {
      var c = l(a2), d = J.call(this, a2);
      c && z(b, a2);
      return d;
    });
    q(Node.prototype, "replaceChild", function(a2, c) {
      if (a2 instanceof DocumentFragment) {
        var d = Array.prototype.slice.apply(a2.childNodes);
        a2 = K.call(this, a2, c);
        if (l(this))
          for (z(b, c), c = 0; c < d.length; c++)
            x(b, d[c]);
        return a2;
      }
      var d = l(a2), e = K.call(this, a2, c), f = l(this);
      f && z(b, c);
      d && z(b, a2);
      f && x(b, a2);
      return e;
    });
    L && L.get ? a(Node.prototype, L) : t(b, function(b2) {
      a(b2, { enumerable: true, configurable: true, get: function() {
        for (var a2 = [], b3 = 0; b3 < this.childNodes.length; b3++)
          a2.push(this.childNodes[b3].textContent);
        return a2.join("");
      }, set: function(a2) {
        for (; this.firstChild; )
          J.call(this, this.firstChild);
        H.call(this, document.createTextNode(a2));
      } });
    });
  }
  ;
  function sa(b) {
    var a = Element.prototype;
    a.before = function(a2) {
      for (var c = [], d = 0; d < arguments.length; ++d)
        c[d - 0] = arguments[d];
      d = c.filter(function(a3) {
        return a3 instanceof Node && l(a3);
      });
      ja.apply(this, c);
      for (var e = 0; e < d.length; e++)
        z(b, d[e]);
      if (l(this))
        for (d = 0; d < c.length; d++)
          e = c[d], e instanceof Element && x(b, e);
    };
    a.after = function(a2) {
      for (var c = [], d = 0; d < arguments.length; ++d)
        c[d - 0] = arguments[d];
      d = c.filter(function(a3) {
        return a3 instanceof Node && l(a3);
      });
      ka.apply(this, c);
      for (var e = 0; e < d.length; e++)
        z(b, d[e]);
      if (l(this))
        for (d = 0; d < c.length; d++)
          e = c[d], e instanceof Element && x(b, e);
    };
    a.replaceWith = function(a2) {
      for (var c = [], d = 0; d < arguments.length; ++d)
        c[d - 0] = arguments[d];
      var d = c.filter(function(a3) {
        return a3 instanceof Node && l(a3);
      }), e = l(this);
      la.apply(this, c);
      for (var f = 0; f < d.length; f++)
        z(b, d[f]);
      if (e)
        for (z(b, this), d = 0; d < c.length; d++)
          e = c[d], e instanceof Element && x(b, e);
    };
    a.remove = function() {
      var a2 = l(this);
      ma.call(this);
      a2 && z(b, this);
    };
  }
  ;
  function ta() {
    var b = Y;
    function a(a2, c2) {
      Object.defineProperty(a2, "innerHTML", { enumerable: c2.enumerable, configurable: true, get: c2.get, set: function(a3) {
        var d = this, e2 = void 0;
        l(this) && (e2 = [], n(this, function(a4) {
          a4 !== d && e2.push(a4);
        }));
        c2.set.call(this, a3);
        if (e2)
          for (var f = 0; f < e2.length; f++) {
            var h = e2[f];
            1 === h.__CE_state && b.disconnectedCallback(h);
          }
        this.ownerDocument.__CE_hasRegistry ? A(b, this) : v(b, this);
        return a3;
      } });
    }
    function e(a2, c2) {
      q(a2, "insertAdjacentElement", function(a3, d) {
        var e2 = l(d);
        a3 = c2.call(this, a3, d);
        e2 && z(b, d);
        l(a3) && x(b, d);
        return a3;
      });
    }
    M ? q(Element.prototype, "attachShadow", function(a2) {
      return this.__CE_shadowRoot = a2 = M.call(this, a2);
    }) : console.warn("Custom Elements: `Element#attachShadow` was not patched.");
    if (N && N.get)
      a(Element.prototype, N);
    else if (W && W.get)
      a(HTMLElement.prototype, W);
    else {
      var c = F.call(document, "div");
      t(b, function(b2) {
        a(b2, { enumerable: true, configurable: true, get: function() {
          return G.call(this, true).innerHTML;
        }, set: function(a2) {
          var b3 = "template" === this.localName ? this.content : this;
          for (c.innerHTML = a2; 0 < b3.childNodes.length; )
            J.call(
              b3,
              b3.childNodes[0]
            );
          for (; 0 < c.childNodes.length; )
            H.call(b3, c.childNodes[0]);
        } });
      });
    }
    q(Element.prototype, "setAttribute", function(a2, c2) {
      if (1 !== this.__CE_state)
        return Q.call(this, a2, c2);
      var d = O.call(this, a2);
      Q.call(this, a2, c2);
      c2 = O.call(this, a2);
      b.attributeChangedCallback(this, a2, d, c2, null);
    });
    q(Element.prototype, "setAttributeNS", function(a2, c2, e2) {
      if (1 !== this.__CE_state)
        return T.call(this, a2, c2, e2);
      var d = S.call(this, a2, c2);
      T.call(this, a2, c2, e2);
      e2 = S.call(this, a2, c2);
      b.attributeChangedCallback(this, c2, d, e2, a2);
    });
    q(
      Element.prototype,
      "removeAttribute",
      function(a2) {
        if (1 !== this.__CE_state)
          return R.call(this, a2);
        var c2 = O.call(this, a2);
        R.call(this, a2);
        null !== c2 && b.attributeChangedCallback(this, a2, c2, null, null);
      }
    );
    q(Element.prototype, "removeAttributeNS", function(a2, c2) {
      if (1 !== this.__CE_state)
        return U.call(this, a2, c2);
      var d = S.call(this, a2, c2);
      U.call(this, a2, c2);
      var e2 = S.call(this, a2, c2);
      d !== e2 && b.attributeChangedCallback(this, c2, d, e2, a2);
    });
    X ? e(HTMLElement.prototype, X) : V ? e(Element.prototype, V) : console.warn("Custom Elements: `Element#insertAdjacentElement` was not patched.");
    pa(b, Element.prototype, { j: ha, append: ia });
    sa(b);
  }
  ;
  var Z = window.customElements;
  if (!Z || Z.forcePolyfill || "function" != typeof Z.define || "function" != typeof Z.get) {
    var Y = new r();
    oa();
    qa();
    ra();
    ta();
    document.__CE_hasRegistry = true;
    var ua = new E(Y);
    Object.defineProperty(window, "customElements", { configurable: true, enumerable: true, value: ua });
  }
  ;
}).call(self);

// node_modules/onsenui/esm/polyfills/MutationObserver@0.7.22/MutationObserver.js
(function(global) {
  if (global.JsMutationObserver) {
    return;
  }
  var registrationsTable = /* @__PURE__ */ new WeakMap();
  var setImmediate2;
  if (/Trident|Edge/.test(navigator.userAgent)) {
    setImmediate2 = setTimeout;
  } else if (window.setImmediate) {
    setImmediate2 = window.setImmediate;
  } else {
    var setImmediateQueue = [];
    var sentinel = String(Math.random());
    window.addEventListener("message", function(e) {
      if (e.data === sentinel) {
        var queue = setImmediateQueue;
        setImmediateQueue = [];
        queue.forEach(function(func) {
          func();
        });
      }
    });
    setImmediate2 = function(func) {
      setImmediateQueue.push(func);
      window.postMessage(sentinel, "*");
    };
  }
  var isScheduled = false;
  var scheduledObservers = [];
  function scheduleCallback(observer) {
    scheduledObservers.push(observer);
    if (!isScheduled) {
      isScheduled = true;
      setImmediate2(dispatchCallbacks);
    }
  }
  function wrapIfNeeded(node) {
    return window.ShadowDOMPolyfill && window.ShadowDOMPolyfill.wrapIfNeeded(node) || node;
  }
  function dispatchCallbacks() {
    isScheduled = false;
    var observers = scheduledObservers;
    scheduledObservers = [];
    observers.sort(function(o1, o2) {
      return o1.uid_ - o2.uid_;
    });
    var anyNonEmpty = false;
    observers.forEach(function(observer) {
      var queue = observer.takeRecords();
      removeTransientObserversFor(observer);
      if (queue.length) {
        observer.callback_(queue, observer);
        anyNonEmpty = true;
      }
    });
    if (anyNonEmpty)
      dispatchCallbacks();
  }
  function removeTransientObserversFor(observer) {
    observer.nodes_.forEach(function(node) {
      var registrations = registrationsTable.get(node);
      if (!registrations)
        return;
      registrations.forEach(function(registration) {
        if (registration.observer === observer)
          registration.removeTransientObservers();
      });
    });
  }
  function forEachAncestorAndObserverEnqueueRecord(target, callback) {
    for (var node = target; node; node = node.parentNode) {
      var registrations = registrationsTable.get(node);
      if (registrations) {
        for (var j = 0; j < registrations.length; j++) {
          var registration = registrations[j];
          var options = registration.options;
          if (node !== target && !options.subtree)
            continue;
          var record = callback(options);
          if (record)
            registration.enqueue(record);
        }
      }
    }
  }
  var uidCounter = 0;
  function JsMutationObserver(callback) {
    this.callback_ = callback;
    this.nodes_ = [];
    this.records_ = [];
    this.uid_ = ++uidCounter;
  }
  JsMutationObserver.prototype = {
    observe: function(target, options) {
      target = wrapIfNeeded(target);
      if (!options.childList && !options.attributes && !options.characterData || options.attributeOldValue && !options.attributes || options.attributeFilter && options.attributeFilter.length && !options.attributes || options.characterDataOldValue && !options.characterData) {
        throw new SyntaxError();
      }
      var registrations = registrationsTable.get(target);
      if (!registrations)
        registrationsTable.set(target, registrations = []);
      var registration;
      for (var i = 0; i < registrations.length; i++) {
        if (registrations[i].observer === this) {
          registration = registrations[i];
          registration.removeListeners();
          registration.options = options;
          break;
        }
      }
      if (!registration) {
        registration = new Registration(this, target, options);
        registrations.push(registration);
        this.nodes_.push(target);
      }
      registration.addListeners();
    },
    disconnect: function() {
      this.nodes_.forEach(function(node) {
        var registrations = registrationsTable.get(node);
        for (var i = 0; i < registrations.length; i++) {
          var registration = registrations[i];
          if (registration.observer === this) {
            registration.removeListeners();
            registrations.splice(i, 1);
            break;
          }
        }
      }, this);
      this.records_ = [];
    },
    takeRecords: function() {
      var copyOfRecords = this.records_;
      this.records_ = [];
      return copyOfRecords;
    }
  };
  function MutationRecord(type, target) {
    this.type = type;
    this.target = target;
    this.addedNodes = [];
    this.removedNodes = [];
    this.previousSibling = null;
    this.nextSibling = null;
    this.attributeName = null;
    this.attributeNamespace = null;
    this.oldValue = null;
  }
  function copyMutationRecord(original) {
    var record = new MutationRecord(original.type, original.target);
    record.addedNodes = original.addedNodes.slice();
    record.removedNodes = original.removedNodes.slice();
    record.previousSibling = original.previousSibling;
    record.nextSibling = original.nextSibling;
    record.attributeName = original.attributeName;
    record.attributeNamespace = original.attributeNamespace;
    record.oldValue = original.oldValue;
    return record;
  }
  var currentRecord, recordWithOldValue;
  function getRecord(type, target) {
    return currentRecord = new MutationRecord(type, target);
  }
  function getRecordWithOldValue(oldValue) {
    if (recordWithOldValue)
      return recordWithOldValue;
    recordWithOldValue = copyMutationRecord(currentRecord);
    recordWithOldValue.oldValue = oldValue;
    return recordWithOldValue;
  }
  function clearRecords() {
    currentRecord = recordWithOldValue = void 0;
  }
  function recordRepresentsCurrentMutation(record) {
    return record === recordWithOldValue || record === currentRecord;
  }
  function selectRecord(lastRecord, newRecord) {
    if (lastRecord === newRecord)
      return lastRecord;
    if (recordWithOldValue && recordRepresentsCurrentMutation(lastRecord))
      return recordWithOldValue;
    return null;
  }
  function Registration(observer, target, options) {
    this.observer = observer;
    this.target = target;
    this.options = options;
    this.transientObservedNodes = [];
  }
  Registration.prototype = {
    enqueue: function(record) {
      var records = this.observer.records_;
      var length = records.length;
      if (records.length > 0) {
        var lastRecord = records[length - 1];
        var recordToReplaceLast = selectRecord(lastRecord, record);
        if (recordToReplaceLast) {
          records[length - 1] = recordToReplaceLast;
          return;
        }
      } else {
        scheduleCallback(this.observer);
      }
      records[length] = record;
    },
    addListeners: function() {
      this.addListeners_(this.target);
    },
    addListeners_: function(node) {
      var options = this.options;
      if (options.attributes)
        node.addEventListener("DOMAttrModified", this, true);
      if (options.characterData)
        node.addEventListener("DOMCharacterDataModified", this, true);
      if (options.childList)
        node.addEventListener("DOMNodeInserted", this, true);
      if (options.childList || options.subtree)
        node.addEventListener("DOMNodeRemoved", this, true);
    },
    removeListeners: function() {
      this.removeListeners_(this.target);
    },
    removeListeners_: function(node) {
      var options = this.options;
      if (options.attributes)
        node.removeEventListener("DOMAttrModified", this, true);
      if (options.characterData)
        node.removeEventListener("DOMCharacterDataModified", this, true);
      if (options.childList)
        node.removeEventListener("DOMNodeInserted", this, true);
      if (options.childList || options.subtree)
        node.removeEventListener("DOMNodeRemoved", this, true);
    },
    addTransientObserver: function(node) {
      if (node === this.target)
        return;
      this.addListeners_(node);
      this.transientObservedNodes.push(node);
      var registrations = registrationsTable.get(node);
      if (!registrations)
        registrationsTable.set(node, registrations = []);
      registrations.push(this);
    },
    removeTransientObservers: function() {
      var transientObservedNodes = this.transientObservedNodes;
      this.transientObservedNodes = [];
      transientObservedNodes.forEach(function(node) {
        this.removeListeners_(node);
        var registrations = registrationsTable.get(node);
        for (var i = 0; i < registrations.length; i++) {
          if (registrations[i] === this) {
            registrations.splice(i, 1);
            break;
          }
        }
      }, this);
    },
    handleEvent: function(e) {
      e.stopImmediatePropagation();
      switch (e.type) {
        case "DOMAttrModified":
          var name = e.attrName;
          var namespace = e.relatedNode.namespaceURI;
          var target = e.target;
          var record = new getRecord("attributes", target);
          record.attributeName = name;
          record.attributeNamespace = namespace;
          var oldValue = e.attrChange === MutationEvent.ADDITION ? null : e.prevValue;
          forEachAncestorAndObserverEnqueueRecord(target, function(options) {
            if (!options.attributes)
              return;
            if (options.attributeFilter && options.attributeFilter.length && options.attributeFilter.indexOf(name) === -1 && options.attributeFilter.indexOf(namespace) === -1) {
              return;
            }
            if (options.attributeOldValue)
              return getRecordWithOldValue(oldValue);
            return record;
          });
          break;
        case "DOMCharacterDataModified":
          var target = e.target;
          var record = getRecord("characterData", target);
          var oldValue = e.prevValue;
          forEachAncestorAndObserverEnqueueRecord(target, function(options) {
            if (!options.characterData)
              return;
            if (options.characterDataOldValue)
              return getRecordWithOldValue(oldValue);
            return record;
          });
          break;
        case "DOMNodeRemoved":
          this.addTransientObserver(e.target);
        case "DOMNodeInserted":
          var changedNode = e.target;
          var addedNodes, removedNodes;
          if (e.type === "DOMNodeInserted") {
            addedNodes = [changedNode];
            removedNodes = [];
          } else {
            addedNodes = [];
            removedNodes = [changedNode];
          }
          var previousSibling = changedNode.previousSibling;
          var nextSibling = changedNode.nextSibling;
          var record = getRecord("childList", e.target.parentNode);
          record.addedNodes = addedNodes;
          record.removedNodes = removedNodes;
          record.previousSibling = previousSibling;
          record.nextSibling = nextSibling;
          forEachAncestorAndObserverEnqueueRecord(e.relatedNode, function(options) {
            if (!options.childList)
              return;
            return record;
          });
      }
      clearRecords();
    }
  };
  global.JsMutationObserver = JsMutationObserver;
  if (!global.MutationObserver) {
    global.MutationObserver = JsMutationObserver;
    JsMutationObserver._isPolyfilled = true;
  }
})(self);

// node_modules/onsenui/esm/polyfills/setImmediate@1.0.2+mod/setImmediate.js
(function(global, undefined2) {
  "use strict";
  if (global.setImmediate) {
    return;
  }
  var nextHandle = 1;
  var tasksByHandle = {};
  var currentlyRunningATask = false;
  var doc = global.document;
  var setImmediate2;
  function addFromSetImmediateArguments(args) {
    tasksByHandle[nextHandle] = partiallyApplied.apply(undefined2, args);
    return nextHandle++;
  }
  function partiallyApplied(handler) {
    var args = [].slice.call(arguments, 1);
    return function() {
      if (typeof handler === "function") {
        handler.apply(undefined2, args);
      } else {
        new Function("" + handler)();
      }
    };
  }
  function runIfPresent(handle) {
    if (currentlyRunningATask) {
      setTimeout(partiallyApplied(runIfPresent, handle), 0);
    } else {
      var task = tasksByHandle[handle];
      if (task) {
        currentlyRunningATask = true;
        try {
          task();
        } finally {
          clearImmediate(handle);
          currentlyRunningATask = false;
        }
      }
    }
  }
  function clearImmediate(handle) {
    delete tasksByHandle[handle];
  }
  function installNextTickImplementation() {
    setImmediate2 = function() {
      var handle = addFromSetImmediateArguments(arguments);
      process.nextTick(partiallyApplied(runIfPresent, handle));
      return handle;
    };
  }
  function canUsePostMessage() {
    if (global.postMessage && !global.importScripts) {
      var postMessageIsAsynchronous = true;
      var oldOnMessage = global.onmessage;
      global.onmessage = function() {
        postMessageIsAsynchronous = false;
      };
      global.postMessage("", "*");
      global.onmessage = oldOnMessage;
      return postMessageIsAsynchronous;
    }
  }
  function installPostMessageImplementation() {
    var messagePrefix = "setImmediate$" + Math.random() + "$";
    var onGlobalMessage = function(event) {
      if (event.source === global && typeof event.data === "string" && event.data.indexOf(messagePrefix) === 0) {
        runIfPresent(+event.data.slice(messagePrefix.length));
      }
    };
    if (global.addEventListener) {
      global.addEventListener("message", onGlobalMessage, false);
    } else {
      global.attachEvent("onmessage", onGlobalMessage);
    }
    setImmediate2 = function() {
      var handle = addFromSetImmediateArguments(arguments);
      global.postMessage(messagePrefix + handle, "*");
      return handle;
    };
  }
  function installMessageChannelImplementation() {
    var channel = new MessageChannel();
    channel.port1.onmessage = function(event) {
      var handle = event.data;
      runIfPresent(handle);
    };
    setImmediate2 = function() {
      var handle = addFromSetImmediateArguments(arguments);
      channel.port2.postMessage(handle);
      return handle;
    };
  }
  function installReadyStateChangeImplementation() {
    var html = doc.documentElement;
    setImmediate2 = function() {
      var handle = addFromSetImmediateArguments(arguments);
      var script = doc.createElement("script");
      script.onreadystatechange = function() {
        runIfPresent(handle);
        script.onreadystatechange = null;
        html.removeChild(script);
        script = null;
      };
      html.appendChild(script);
      return handle;
    };
  }
  function installSetTimeoutImplementation() {
    setImmediate2 = function() {
      var handle = addFromSetImmediateArguments(arguments);
      setTimeout(partiallyApplied(runIfPresent, handle), 0);
      return handle;
    };
  }
  var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);
  attachTo = attachTo && attachTo.setTimeout ? attachTo : global;
  if ({}.toString.call(global.process) === "[object process]") {
    installNextTickImplementation();
  } else if (canUsePostMessage()) {
    installPostMessageImplementation();
  } else if (global.MessageChannel) {
    installMessageChannelImplementation();
  } else if (doc && "onreadystatechange" in doc.createElement("script")) {
    installReadyStateChangeImplementation();
  } else {
    installSetTimeoutImplementation();
  }
  attachTo.setImmediate = setImmediate2;
  attachTo.clearImmediate = clearImmediate;
})(self);

// node_modules/onsenui/esm/vendor/viewport.js
(function() {
  var DEFAULT_VIEWPORT = "width=device-width,initial-scale=1,maximum-scale=1,minimum-scale=1,user-scalable=no";
  var Viewport2 = {
    ensureViewportElement: function() {
      var viewportElement = document.querySelector("meta[name=viewport]");
      if (!viewportElement) {
        viewportElement = document.createElement("meta");
        viewportElement.name = "viewport";
        document.head.appendChild(viewportElement);
      }
      return viewportElement;
    },
    setup: function() {
      var viewportElement = Viewport2.ensureViewportElement();
      if (!viewportElement) {
        return;
      }
      if (!viewportElement.hasAttribute("content")) {
        viewportElement.setAttribute("content", DEFAULT_VIEWPORT);
      }
    }
  };
  window.Viewport = Viewport2;
})();

// node_modules/onsenui/esm/ons/microevent.js
var MicroEvent = function() {
};
MicroEvent.prototype = {
  on: function(event, fct) {
    this._events = this._events || {};
    this._events[event] = this._events[event] || [];
    this._events[event].push(fct);
  },
  once: function(event, fct) {
    var self2 = this;
    var wrapper = function() {
      self2.off(event, wrapper);
      return fct.apply(null, arguments);
    };
    this.on(event, wrapper);
  },
  off: function(event, fct) {
    this._events = this._events || {};
    if (event in this._events === false) {
      return;
    }
    this._events[event] = this._events[event].filter(function(_fct) {
      if (fct) {
        return fct !== _fct;
      } else {
        return false;
      }
    });
  },
  emit: function(event) {
    this._events = this._events || {};
    if (event in this._events === false) {
      return;
    }
    for (var i = 0; i < this._events[event].length; i++) {
      this._events[event][i].apply(this, Array.prototype.slice.call(arguments, 1));
    }
  }
};
MicroEvent.mixin = function(destObject) {
  var props = ["on", "once", "off", "emit"];
  for (var i = 0; i < props.length; i++) {
    if (typeof destObject === "function") {
      destObject.prototype[props[i]] = MicroEvent.prototype[props[i]];
    } else {
      destObject[props[i]] = MicroEvent.prototype[props[i]];
    }
  }
};
window.MicroEvent = MicroEvent;
var microevent_default = MicroEvent;

// node_modules/onsenui/esm/ons/elements.js
var elements_default = {};

// node_modules/onsenui/esm/ons/styler.js
var prefix = function() {
  const styles = window.getComputedStyle(document.documentElement, "");
  const prefix2 = (Array.prototype.slice.call(styles).join("").match(/-(moz|webkit|ms)-/) || styles.OLink === "" && ["", "o"])[1];
  return function(name) {
    return "-" + prefix2 + "-" + util_default.hyphenate(name);
  };
}();
var styler = function(element, style) {
  Object.keys(style).forEach(function(key) {
    if (key in element.style) {
      element.style[key] = style[key];
    } else if (prefix(key) in element.style) {
      element.style[prefix(key)] = style[key];
    } else {
      util_default.warn("No such style property: " + key);
    }
  });
  return element;
};
styler.clear = function(element, styles = "") {
  const clearlist = styles.split(/\s+/).reduce((r, s) => r.concat([util_default.hyphenate(s), prefix(s)]), []), keys = [];
  for (let i = element.style.length - 1; i >= 0; i--) {
    const key = element.style[i];
    if (clearlist.length === 0 || clearlist.some((s) => key.indexOf(s) === 0)) {
      keys.push(key);
    }
  }
  keys.forEach((key) => element.style[key] = "");
  element.getAttribute("style") === "" && element.removeAttribute("style");
};
var styler_default = styler;

// node_modules/onsenui/esm/ons/autostyle.js
var autoStyleEnabled = true;
var modifiersMap = {
  "quiet": "material--flat",
  "light": "material--flat",
  "outline": "material--flat",
  "cta": "",
  "large--quiet": "material--flat large",
  "large--cta": "large",
  "noborder": "",
  "tappable": ""
};
var platforms = {};
platforms.android = (element) => {
  const elementName = element.tagName.toLowerCase();
  if (!util_default.hasModifier(element, "material")) {
    const oldModifier = element.getAttribute("modifier") || "";
    const newModifier = oldModifier.trim().split(/\s+/).map((e) => Object.prototype.hasOwnProperty.call(modifiersMap, e) ? modifiersMap[e] : e);
    newModifier.unshift("material");
    element.setAttribute("modifier", newModifier.join(" ").trim());
  }
  const elements = [
    "ons-alert-dialog-button",
    "ons-toolbar-button",
    "ons-back-button",
    "ons-button",
    "ons-list-item",
    "ons-fab",
    "ons-speed-dial",
    "ons-speed-dial-item",
    "ons-tab"
  ];
  if (elements.indexOf(elementName) !== -1 && !element.hasAttribute("ripple") && !element.querySelector("ons-ripple")) {
    if (elementName === "ons-list-item") {
      if (element.hasAttribute("tappable")) {
        element.setAttribute("ripple", "");
        element.removeAttribute("tappable");
      }
    } else {
      element.setAttribute("ripple", "");
    }
  }
};
platforms.ios = (element) => {
  if (util_default.removeModifier(element, "material")) {
    if (util_default.removeModifier(element, "material--flat")) {
      util_default.addModifier(element, util_default.removeModifier(element, "large") ? "large--quiet" : "quiet");
    }
    if (!element.getAttribute("modifier")) {
      element.removeAttribute("modifier");
    }
  }
  if (element.hasAttribute("ripple")) {
    if (element.tagName.toLowerCase() === "ons-list-item") {
      element.setAttribute("tappable", "");
    }
    element.removeAttribute("ripple");
  }
};
var unlocked = {
  android: true
};
var getPlatform = (element, force) => {
  if (autoStyleEnabled && !element.hasAttribute("disable-auto-styling")) {
    const mobileOS = platform_default.getMobileOS();
    if (Object.prototype.hasOwnProperty.call(platforms, mobileOS) && (Object.prototype.hasOwnProperty.call(unlocked, mobileOS) || force)) {
      return mobileOS;
    }
  }
  return null;
};
var prepare = (element, force) => {
  const p = getPlatform(element, force);
  p && platforms[p](element);
};
var mapModifier = (modifier, element, force) => {
  if (getPlatform(element, force)) {
    return modifier.split(/\s+/).map((m) => Object.prototype.hasOwnProperty.call(modifiersMap, m) ? modifiersMap[m] : m).join(" ");
  }
  return modifier;
};
var restoreModifier = (element) => {
  if (getPlatform(element) === "android") {
    const modifier = element.getAttribute("modifier") || "";
    let newModifier = mapModifier(modifier, element);
    if (!/(^|\s+)material($|\s+)/i.test(modifier)) {
      newModifier = "material " + newModifier;
    }
    if (newModifier !== modifier) {
      element.setAttribute("modifier", newModifier.trim());
      return true;
    }
  }
  return false;
};
var autostyle_default = {
  isEnabled: () => autoStyleEnabled,
  enable: () => autoStyleEnabled = true,
  disable: () => autoStyleEnabled = false,
  prepare,
  mapModifier,
  getPlatform,
  restoreModifier
};

// node_modules/onsenui/esm/ons/internal/modifier-util.js
var ModifierUtil = class _ModifierUtil {
  /**
   * @param {String} last
   * @param {String} current
   */
  static diff(last, current) {
    last = makeDict(("" + last).trim());
    current = makeDict(("" + current).trim());
    const removed = Object.keys(last).reduce((result, token) => {
      if (!current[token]) {
        result.push(token);
      }
      return result;
    }, []);
    const added = Object.keys(current).reduce((result, token) => {
      if (!last[token]) {
        result.push(token);
      }
      return result;
    }, []);
    return { added, removed };
    function makeDict(modifier) {
      const dict = {};
      _ModifierUtil.split(modifier).forEach((token) => dict[token] = token);
      return dict;
    }
  }
  /**
   * @param {Object} diff
   * @param {Array} diff.removed
   * @param {Array} diff.added
   * @param {Object} classList
   * @param {String} template
   */
  static applyDiffToClassList(diff, classList, template) {
    diff.added.map((modifier) => template.replace(/\*/g, modifier)).forEach((klass) => klass.split(/\s+/).forEach((k) => classList.add(k)));
    diff.removed.map((modifier) => template.replace(/\*/g, modifier)).forEach((klass) => klass.split(/\s+/).forEach((k) => classList.remove(k)));
  }
  /**
   * @param {Object} diff
   * @param {Array} diff.removed
   * @param {Array} diff.added
   * @param {HTMLElement} element
   * @param {Object} scheme
   */
  static applyDiffToElement(diff, element, scheme) {
    Object.keys(scheme).forEach((selector) => {
      const targetElements = !selector || util_default.match(element, selector) ? [element] : Array.prototype.filter.call(
        element.querySelectorAll(selector),
        (targetElement) => !util_default.findParent(targetElement, element.tagName, (parent) => parent === element)
      );
      for (let i = 0; i < targetElements.length; i++) {
        _ModifierUtil.applyDiffToClassList(diff, targetElements[i].classList, scheme[selector]);
      }
    });
  }
  /**
   * @param {String} last
   * @param {String} current
   * @param {HTMLElement} element
   * @param {Object} scheme
   */
  static onModifierChanged(last, current, element, scheme) {
    _ModifierUtil.applyDiffToElement(_ModifierUtil.diff(last, current), element, scheme);
    autostyle_default.restoreModifier(element);
  }
  static refresh(element, scheme) {
    _ModifierUtil.applyDiffToElement(_ModifierUtil.diff("", element.getAttribute("modifier") || ""), element, scheme);
  }
  /**
   * @param {HTMLElement} element
   * @param {Object} scheme
   */
  static initModifier(element, scheme) {
    const modifier = element.getAttribute("modifier");
    if (typeof modifier !== "string") {
      return;
    }
    _ModifierUtil.applyDiffToElement({
      removed: [],
      added: _ModifierUtil.split(modifier)
    }, element, scheme);
  }
  static split(modifier) {
    if (typeof modifier !== "string") {
      return [];
    }
    return modifier.trim().split(/ +/).filter((token) => token !== "");
  }
  /**
   * Add modifier token to an element.
   */
  static addModifier(element, modifierToken) {
    if (!element.hasAttribute("modifier")) {
      element.setAttribute("modifier", modifierToken);
    } else {
      const tokens = _ModifierUtil.split(element.getAttribute("modifier"));
      if (tokens.indexOf(modifierToken) == -1) {
        tokens.push(modifierToken);
        element.setAttribute("modifier", tokens.join(" "));
      }
    }
  }
  /**
   * Remove modifier token from an element.
   */
  static removeModifier(element, modifierToken) {
    if (element.hasAttribute("modifier")) {
      const tokens = _ModifierUtil.split(element.getAttribute("modifier"));
      const index = tokens.indexOf(modifierToken);
      if (index !== -1) {
        tokens.splice(index, 1);
        element.setAttribute("modifier", tokens.join(" "));
      }
    }
  }
};

// node_modules/onsenui/esm/ons/animation-options-parser.js
var startsWith = (s, c) => s.substr(0, c.length) === c;
var endsWith = (s, c) => s.substr(s.length - c.length, c.length) === c;
var unwrap = (s) => s.slice(1, -1);
var isObjectString = (s) => startsWith(s, "{") && endsWith(s, "}");
var isArrayString = (s) => startsWith(s, "[") && endsWith(s, "]");
var isQuotedString = (s) => startsWith(s, "'") && endsWith(s, "'") || startsWith(s, '"') && endsWith(s, '"');
var error = (token, string, originalString) => {
  throw new Error("Unexpected token '" + token + "' at position " + (originalString.length - string.length - 1) + " in string: '" + originalString + "'");
};
var processToken = (token, string, originalString) => {
  if (token === "true" || token === "false") {
    return token === "true";
  } else if (isQuotedString(token)) {
    return unwrap(token);
  } else if (!isNaN(token)) {
    return +token;
  } else if (isObjectString(token)) {
    return parseObject(unwrap(token));
  } else if (isArrayString(token)) {
    return parseArray(unwrap(token));
  } else {
    error(token, string, originalString);
  }
};
var nextToken = (string) => {
  string = string.trim();
  let limit = string.length;
  if (string[0] === ":" || string[0] === ",") {
    limit = 1;
  } else if (string[0] === "{" || string[0] === "[") {
    const c = string.charCodeAt(0);
    let nestedObject = 1;
    for (let i = 1; i < string.length; i++) {
      if (string.charCodeAt(i) === c) {
        nestedObject++;
      } else if (string.charCodeAt(i) === c + 2) {
        nestedObject--;
        if (nestedObject === 0) {
          limit = i + 1;
          break;
        }
      }
    }
  } else if (string[0] === "'" || string[0] === '"') {
    for (let i = 1; i < string.length; i++) {
      if (string[i] === string[0]) {
        limit = i + 1;
        break;
      }
    }
  } else {
    for (let i = 1; i < string.length; i++) {
      if ([" ", ",", ":"].indexOf(string[i]) !== -1) {
        limit = i;
        break;
      }
    }
  }
  return string.slice(0, limit);
};
var parseObject = (string) => {
  const isValidKey = (key2) => /^[A-Z_$][A-Z0-9_$]*$/i.test(key2);
  string = string.trim();
  const originalString = string;
  const object = {};
  let readingKey = true, key, previousToken, token;
  while (string.length > 0) {
    previousToken = token;
    token = nextToken(string);
    string = string.slice(token.length, string.length).trim();
    if (token === ":" && (!readingKey || !previousToken || previousToken === ",") || token === "," && readingKey || token !== ":" && token !== "," && (previousToken && previousToken !== "," && previousToken !== ":")) {
      error(token, string, originalString);
    } else if (token === ":" && readingKey && previousToken) {
      previousToken = isQuotedString(previousToken) ? unwrap(previousToken) : previousToken;
      if (isValidKey(previousToken)) {
        key = previousToken;
        readingKey = false;
      } else {
        throw new Error("Invalid key token '" + previousToken + "' at position 0 in string: '" + originalString + "'");
      }
    } else if (token === "," && !readingKey && previousToken) {
      object[key] = processToken(previousToken, string, originalString);
      readingKey = true;
    }
  }
  if (token) {
    object[key] = processToken(token, string, originalString);
  }
  return object;
};
var parseArray = (string) => {
  string = string.trim();
  const originalString = string;
  const array = [];
  let previousToken, token;
  while (string.length > 0) {
    previousToken = token;
    token = nextToken(string);
    string = string.slice(token.length, string.length).trim();
    if (token === "," && (!previousToken || previousToken === ",")) {
      error(token, string, originalString);
    } else if (token === ",") {
      array.push(processToken(previousToken, string, originalString));
    }
  }
  if (token) {
    if (token !== ",") {
      array.push(processToken(token, string, originalString));
    } else {
      error(token, string, originalString);
    }
  }
  return array;
};
var parse = (string) => {
  string = string.trim();
  if (isObjectString(string)) {
    return parseObject(unwrap(string));
  } else if (isArrayString(string)) {
    return parseArray(unwrap(string));
  } else {
    throw new Error("Provided string must be object or array like: " + string);
  }
};
var animation_options_parser_default = parse;

// node_modules/onsenui/esm/ons/util.js
var util = {};
var errorPrefix = "[Onsen UI]";
util.globals = {
  fabOffset: 0,
  errorPrefix,
  supportsPassive: false
};
platform_default._runOnActualPlatform(() => {
  util.globals.actualMobileOS = platform_default.getMobileOS();
  util.globals.isWKWebView = platform_default.isWKWebView();
});
try {
  const opts = Object.defineProperty({}, "passive", {
    get() {
      util.globals.supportsPassive = true;
    }
    // eslint-disable-line getter-return
  });
  window.addEventListener("testPassive", null, opts);
  window.removeEventListener("testPassive", null, opts);
} catch (e) {
  null;
}
util.addEventListener = (el2, name, handler, opt, isGD) => {
  el2.addEventListener(name, handler, util.globals.supportsPassive ? opt : (opt || {}).capture);
};
util.removeEventListener = (el2, name, handler, opt, isGD) => {
  el2.removeEventListener(name, handler, util.globals.supportsPassive ? opt : (opt || {}).capture);
};
util.prepareQuery = (query) => {
  return query instanceof Function ? query : (element) => util.match(element, query);
};
util.match = (e, s) => (e.matches || e.webkitMatchesSelector || e.mozMatchesSelector || e.msMatchesSelector).call(e, s);
util.findChild = (element, query) => {
  const match = util.prepareQuery(query);
  for (let i = 0; i < element.childNodes.length; i++) {
    const node = element.childNodes[i];
    if (node.nodeType !== Node.ELEMENT_NODE) {
      continue;
    }
    if (match(node)) {
      return node;
    }
  }
  return null;
};
util.findParent = (element, query, until) => {
  const match = util.prepareQuery(query);
  let parent = element.parentNode;
  for (; ; ) {
    if (!parent || parent === document || parent instanceof DocumentFragment || until && until(parent)) {
      return null;
    } else if (match(parent)) {
      return parent;
    }
    parent = parent.parentNode;
  }
};
util.isAttached = (element) => document.body.contains(element);
util.hasAnyComponentAsParent = (element) => {
  while (element && document.documentElement !== element) {
    element = element.parentNode;
    if (element && element.nodeName.toLowerCase().match(/(ons-navigator|ons-tabbar|ons-modal)/)) {
      return true;
    }
  }
  return false;
};
util.getAllChildNodes = (element) => {
  return [element].concat(
    ...Array.from(element.children).map((childEl) => {
      return util.getAllChildNodes(childEl);
    })
  );
};
util.isPageControl = (element) => element.nodeName.match(/^ons-(navigator|splitter|tabbar|page)$/i);
util.propagateAction = (element, action) => {
  for (let i = 0; i < element.childNodes.length; i++) {
    const child = element.childNodes[i];
    if (child[action] instanceof Function) {
      child[action]();
    } else {
      util.propagateAction(child, action);
    }
  }
};
util.camelize = (string) => string.toLowerCase().replace(/-([a-z])/g, (m, l) => l.toUpperCase());
util.hyphenate = (string) => string.replace(/([a-zA-Z])([A-Z])/g, "$1-$2").toLowerCase();
util.create = (selector = "", style = {}) => {
  const classList = selector.split(".");
  const element = document.createElement(classList.shift() || "div");
  if (classList.length) {
    element.className = classList.join(" ");
  }
  styler_default(element, style);
  return element;
};
util.createElement = (html) => {
  const wrapper = document.createElement("div");
  if (html instanceof DocumentFragment) {
    wrapper.appendChild(document.importNode(html, true));
  } else {
    wrapper.innerHTML = html.trim();
  }
  if (wrapper.children.length > 1) {
    util.throw("HTML template must contain a single root element");
  }
  const element = wrapper.children[0];
  wrapper.children[0].remove();
  return element;
};
util.createFragment = (html) => {
  const template = document.createElement("template");
  template.innerHTML = html;
  return document.importNode(template.content, true);
};
util.extend = (dst, ...args) => {
  for (let i = 0; i < args.length; i++) {
    if (args[i]) {
      const keys = Object.keys(args[i]);
      for (let j = 0; j < keys.length; j++) {
        const key = keys[j];
        dst[key] = args[i][key];
      }
    }
  }
  return dst;
};
util.arrayFrom = (arrayLike) => {
  return Array.prototype.slice.apply(arrayLike);
};
util.parseJSONObjectSafely = (jsonString, failSafe = {}) => {
  try {
    const result = JSON.parse("" + jsonString);
    if (typeof result === "object" && result !== null) {
      return result;
    }
  } catch (e) {
    return failSafe;
  }
  return failSafe;
};
util.findFromPath = (path) => {
  path = path.split(".");
  var el2 = window, key;
  while (key = path.shift()) {
    el2 = el2[key];
  }
  return el2;
};
util.getTopPage = (container) => container && (container.tagName.toLowerCase() === "ons-page" ? container : container.topPage) || null;
util.findToolbarPage = (container) => {
  const page = util.getTopPage(container);
  if (page) {
    if (page._canAnimateToolbar()) {
      return page;
    }
    for (let i = 0; i < page._contentElement.children.length; i++) {
      const nextPage = util.getTopPage(page._contentElement.children[i]);
      if (nextPage && !/ons-tabbar/i.test(page._contentElement.children[i].tagName)) {
        return util.findToolbarPage(nextPage);
      }
    }
  }
  return null;
};
util.triggerElementEvent = (target, eventName, detail = {}) => {
  const event = new CustomEvent(eventName, {
    bubbles: true,
    cancelable: true,
    detail
  });
  Object.keys(detail).forEach((key) => {
    event[key] = detail[key];
  });
  target.dispatchEvent(event);
  return event;
};
util.hasModifier = (target, modifierName) => {
  if (!target.hasAttribute("modifier")) {
    return false;
  }
  return RegExp(`(^|\\s+)${modifierName}($|\\s+)`, "i").test(target.getAttribute("modifier"));
};
util.addModifier = (target, modifierName, options = {}) => {
  if (options.autoStyle) {
    modifierName = autostyle_default.mapModifier(modifierName, target, options.forceAutoStyle);
  }
  if (util.hasModifier(target, modifierName)) {
    return false;
  }
  target.setAttribute("modifier", ((target.getAttribute("modifier") || "") + " " + modifierName).trim());
  return true;
};
util.removeModifier = (target, modifierName, options = {}) => {
  if (options.autoStyle) {
    modifierName = autostyle_default.mapModifier(modifierName, target, options.forceAutoStyle);
  }
  if (!target.getAttribute("modifier") || !util.hasModifier(target, modifierName)) {
    return false;
  }
  const newModifiers = target.getAttribute("modifier").split(/\s+/).filter((m) => m && m !== modifierName);
  newModifiers.length ? target.setAttribute("modifier", newModifiers.join(" ")) : target.removeAttribute("modifier");
  return true;
};
util.toggleModifier = (...args) => {
  const options = args.length > 2 ? args[2] : {};
  const force = typeof options === "boolean" ? options : options.force;
  const toggle = typeof force === "boolean" ? force : !util.hasModifier(...args);
  toggle ? util.addModifier(...args) : util.removeModifier(...args);
};
util.restoreClass = (el2, defaultClass, scheme) => {
  defaultClass.split(/\s+/).forEach((c) => c !== "" && !el2.classList.contains(c) && el2.classList.add(c));
  el2.hasAttribute("modifier") && ModifierUtil.refresh(el2, scheme);
};
util.updateParentPosition = (el2) => {
  if (!el2._parentUpdated && el2.parentElement) {
    if (window.getComputedStyle(el2.parentElement).getPropertyValue("position") === "static") {
      el2.parentElement.style.position = "relative";
    }
    el2._parentUpdated = true;
  }
};
util.toggleAttribute = (element, name, value) => {
  if (value) {
    element.setAttribute(name, typeof value === "boolean" ? "" : value);
  } else {
    element.removeAttribute(name);
  }
};
util.bindListeners = (element, listenerNames) => {
  listenerNames.forEach((name) => {
    const boundName = name.replace(/^_[a-z]/, "_bound" + name[1].toUpperCase());
    element[boundName] = element[boundName] || element[name].bind(element);
  });
};
util.each = (obj, f) => Object.keys(obj).forEach((key) => f(key, obj[key]));
util.updateRipple = (target, hasRipple, attrs = {}) => {
  if (hasRipple === void 0) {
    hasRipple = target.hasAttribute("ripple");
  }
  const rippleElement = util.findChild(target, "ons-ripple");
  if (hasRipple) {
    if (!rippleElement) {
      const element = document.createElement("ons-ripple");
      Object.keys(attrs).forEach((key) => element.setAttribute(key, attrs[key]));
      target.insertBefore(element, target.firstChild);
    }
  } else if (rippleElement) {
    rippleElement.remove();
  }
};
util.animationOptionsParse = animation_options_parser_default;
util.isInteger = (value) => {
  return typeof value === "number" && isFinite(value) && Math.floor(value) === value;
};
util.defer = () => {
  const deferred = {};
  deferred.promise = new Promise((resolve, reject) => {
    deferred.resolve = resolve;
    deferred.reject = reject;
  });
  return deferred;
};
util.warn = (...args) => {
  if (!internal_default.config.warningsDisabled) {
    console.warn(errorPrefix, ...args);
  }
};
util.throw = (message) => {
  throw new Error(`${errorPrefix} ${message}`);
};
util.throwAbstract = () => util.throw("Cannot instantiate abstract class");
util.throwMember = () => util.throw("Class member must be implemented");
util.throwPageLoader = () => util.throw("First parameter should be an instance of PageLoader");
util.throwAnimator = (el2) => util.throw(`"Animator" param must inherit ${el2}Animator`);
var prevent = (e) => e.cancelable && e.preventDefault();
util.iosPreventScroll = (gd) => {
  if (util.globals.actualMobileOS === "ios") {
    const clean = (e) => {
      gd.off("touchmove", prevent);
      gd.off("dragend", clean);
    };
    gd.on("touchmove", prevent);
    gd.on("dragend", clean);
  }
};
util.iosPageScrollFix = (add) => {
  if (util.globals.actualMobileOS === "ios") {
    document.body.classList.toggle("ons-ios-scroll", add);
    document.body.classList.toggle("ons-ios-scroll-fix", add);
  }
};
util.isValidGesture = (event) => event.gesture !== void 0 && (event.gesture.distance <= 15 || event.gesture.deltaTime <= 100);
util.checkMissingImport = (...elementNames) => {
  elementNames.forEach((name) => {
    if (!elements_default[name]) {
      util.throw(`Ons${name} is required but was not imported (Custom Elements)`);
    }
  });
};
util.defineBooleanProperties = (object, attributeList) => {
  attributeList.forEach((attributeName) => {
    const propertyName = util.camelize(attributeName);
    Object.defineProperty(object.prototype, propertyName, {
      get() {
        return this.hasAttribute(attributeName);
      },
      set(value) {
        if (value) {
          this.setAttribute(attributeName, "");
        } else {
          this.removeAttribute(attributeName);
        }
      },
      configurable: true
    });
  });
};
util.defineStringProperties = (object, attributeList) => {
  attributeList.forEach((attributeName) => {
    const propertyName = util.camelize(attributeName);
    Object.defineProperty(object.prototype, propertyName, {
      get() {
        return this.getAttribute(attributeName);
      },
      set(value) {
        if (value === null || value === void 0) {
          this.removeAttribute(attributeName);
        } else {
          this.setAttribute(attributeName, value);
        }
      },
      configurable: true
    });
  });
};
util.defineListenerProperty = (element, eventName) => {
  const camelized = util.camelize(eventName);
  const propertyName = "on" + camelized.charAt(0).toUpperCase() + camelized.slice(1);
  let handler;
  Object.defineProperty(element, propertyName, {
    get() {
      return handler;
    },
    set(newHandler) {
      if (element.isConnected) {
        if (handler) {
          element.removeEventListener(eventName, handler);
        }
        element.addEventListener(eventName, newHandler);
      }
      handler = newHandler;
    },
    configurable: true
  });
  return {
    onConnected() {
      if (element[propertyName]) {
        element.addEventListener(eventName, element[propertyName]);
      }
    },
    onDisconnected() {
      if (element[propertyName]) {
        element.removeEventListener(eventName, element[propertyName]);
      }
    }
  };
};
var util_default = util;

// node_modules/onsenui/esm/ons/page-attribute-expression.js
var error2 = (message) => util_default.throw(`In PageAttributeExpression: ${message}`);
var pageAttributeExpression = {
  _variables: {},
  /**
   * Define a variable.
   *
   * @param {String} name Name of the variable
   * @param {String|Function} value Value of the variable. Can be a string or a function. The function must return a string.
   * @param {Boolean} overwrite If this value is false, an error will be thrown when trying to define a variable that has already been defined.
   */
  defineVariable: function(name, value, overwrite = false) {
    if (typeof name !== "string") {
      error2("Variable name must be a string");
    } else if (typeof value !== "string" && typeof value !== "function") {
      error2("Variable value must be a string or a function");
    } else if (Object.prototype.hasOwnProperty.call(this._variables, name) && !overwrite) {
      error2(`"${name}" is already defined`);
    }
    this._variables[name] = value;
  },
  /**
   * Get a variable.
   *
   * @param {String} name Name of the variable.
   * @return {String|Function|null}
   */
  getVariable: function(name) {
    if (!Object.prototype.hasOwnProperty.call(this._variables, name)) {
      return null;
    }
    return this._variables[name];
  },
  /**
   * Remove a variable.
   *
   * @param {String} name Name of the varaible.
   */
  removeVariable: function(name) {
    delete this._variables[name];
  },
  /**
   * Get all variables.
   *
   * @return {Object}
   */
  getAllVariables: function() {
    return this._variables;
  },
  _parsePart: function(part) {
    let c, inInterpolation = false, currentIndex = 0;
    const tokens = [];
    if (part.length === 0) {
      error2("Unable to parse empty string");
    }
    for (let i = 0; i < part.length; i++) {
      c = part.charAt(i);
      if (c === "$" && part.charAt(i + 1) === "{") {
        if (inInterpolation) {
          error2("Nested interpolation not supported");
        }
        const token = part.substring(currentIndex, i);
        if (token.length > 0) {
          tokens.push(part.substring(currentIndex, i));
        }
        currentIndex = i;
        inInterpolation = true;
      } else if (c === "}") {
        if (!inInterpolation) {
          error2("} must be preceeded by ${");
        }
        const token = part.substring(currentIndex, i + 1);
        if (token.length > 0) {
          tokens.push(part.substring(currentIndex, i + 1));
        }
        currentIndex = i + 1;
        inInterpolation = false;
      }
    }
    if (inInterpolation) {
      error2("Unterminated interpolation");
    }
    tokens.push(part.substring(currentIndex, part.length));
    return tokens;
  },
  _replaceToken: function(token) {
    const re = /^\${(.*?)}$/, match = token.match(re);
    if (match) {
      const name = match[1].trim();
      const variable = this.getVariable(name);
      if (variable === null) {
        error2(`Variable "${name}" does not exist`);
      } else if (typeof variable === "string") {
        return variable;
      } else {
        const rv = variable();
        if (typeof rv !== "string") {
          error2("Must return a string");
        }
        return rv;
      }
    } else {
      return token;
    }
  },
  _replaceTokens: function(tokens) {
    return tokens.map(this._replaceToken.bind(this));
  },
  _parseExpression: function(expression) {
    return expression.split(",").map(
      function(part) {
        return part.trim();
      }
    ).map(this._parsePart.bind(this)).map(this._replaceTokens.bind(this)).map((part) => part.join(""));
  },
  /**
   * Evaluate an expression.
   *
   * @param {String} expression An page attribute expression.
   * @return {Array}
   */
  evaluate: function(expression) {
    if (!expression) {
      return [];
    }
    return this._parseExpression(expression);
  }
};
pageAttributeExpression.defineVariable("mobileOS", platform_default.getMobileOS());
pageAttributeExpression.defineVariable("iOSDevice", platform_default.getIOSDevice());
pageAttributeExpression.defineVariable("runtime", () => {
  return platform_default.isWebView() ? "cordova" : "browser";
});
var page_attribute_expression_default = pageAttributeExpression;

// node_modules/onsenui/esm/ons/internal/internal.js
var internal = {};
internal.config = {
  autoStatusBarFill: true,
  animationsDisabled: false,
  warningsDisabled: false
};
internal.nullElement = window.document.createElement("div");
internal.isEnabledAutoStatusBarFill = () => {
  return !!internal.config.autoStatusBarFill;
};
internal.normalizePageHTML = (html) => ("" + html).trim();
internal.waitDOMContentLoaded = (callback) => {
  if (window.document.readyState === "loading" || window.document.readyState == "uninitialized") {
    const wrappedCallback = () => {
      callback();
      window.document.removeEventListener("DOMContentLoaded", wrappedCallback);
    };
    window.document.addEventListener("DOMContentLoaded", wrappedCallback);
  } else {
    setImmediate(callback);
  }
};
internal.autoStatusBarFill = (action) => {
  const onReady = () => {
    if (internal.shouldFillStatusBar()) {
      action();
    }
    document.removeEventListener("deviceready", onReady);
  };
  if (typeof device === "object") {
    document.addEventListener("deviceready", onReady);
  } else if (["complete", "interactive"].indexOf(document.readyState) === -1) {
    internal.waitDOMContentLoaded(onReady);
  } else {
    onReady();
  }
};
internal.shouldFillStatusBar = () => internal.isEnabledAutoStatusBarFill() && (platform_default.isWebView() && (platform_default.isIOS7above() || platform_default.isIPadOS()) && !platform_default.isIPhoneX() || document.body.querySelector(".ons-status-bar-mock.ios"));
internal.templateStore = {
  _storage: {},
  /**
   * @param {String} key
   * @return {String/null} template
   */
  get(key) {
    return internal.templateStore._storage[key] || null;
  },
  /**
   * @param {String} key
   * @param {String} template
   */
  set(key, template) {
    internal.templateStore._storage[key] = template;
  }
};
internal.getTemplateHTMLAsync = function(page) {
  return new Promise((resolve, reject) => {
    internal.waitDOMContentLoaded(() => {
      const cache = internal.templateStore.get(page);
      if (cache) {
        if (cache instanceof DocumentFragment) {
          return resolve(cache);
        }
        const html = typeof cache === "string" ? cache : cache[1];
        return resolve(internal.normalizePageHTML(html));
      }
      const local = window.document.getElementById(page);
      if (local) {
        const html = local.textContent || local.content;
        return resolve(html);
      }
      const xhr = new XMLHttpRequest();
      xhr.open("GET", page, true);
      xhr.onload = function() {
        const html = xhr.responseText;
        if (xhr.status >= 400 && xhr.status < 600) {
          if (xhr.status === 404) {
            reject(404);
          } else {
            reject(html);
          }
        } else {
          const fragment = util_default.createFragment(html);
          util_default.arrayFrom(fragment.querySelectorAll("script")).forEach((el2) => {
            const script = document.createElement("script");
            script.type = el2.type || "text/javascript";
            script.appendChild(document.createTextNode(el2.text || el2.textContent || el2.innerHTML));
            el2.parentNode.replaceChild(script, el2);
          });
          internal.templateStore.set(page, fragment);
          resolve(fragment);
        }
      };
      xhr.onerror = function() {
        util_default.throw(`Page template not found: ${page}`);
      };
      xhr.send(null);
    });
  });
};
internal.getPageHTMLAsync = function(page) {
  const pages = page_attribute_expression_default.evaluate(page);
  const getPage = (page2) => {
    if (typeof page2 !== "string") {
      return Promise.reject("Must specify a page.");
    }
    return internal.getTemplateHTMLAsync(page2).catch(function(error3) {
      if (pages.length === 0) {
        return Promise.reject(error3);
      }
      return getPage(pages.shift());
    });
  };
  return getPage(pages.shift());
};
var internal_default2 = internal;

// node_modules/onsenui/esm/ons/internal/animator-factory.js
var AnimatorFactory = class {
  /**
   * @param {Object} opts
   * @param {Object} opts.animators The dictionary for animator classes
   * @param {Function} opts.baseClass The base class of animators
   * @param {String} [opts.baseClassName] The name of the base class of animators
   * @param {String} [opts.defaultAnimation] The default animation name
   * @param {Object} [opts.defaultAnimationOptions] The default animation options
   */
  constructor(opts) {
    this._animators = opts.animators;
    this._baseClass = opts.baseClass;
    this._baseClassName = opts.baseClassName || opts.baseClass.name;
    this._animation = opts.defaultAnimation || "default";
    this._animationOptions = opts.defaultAnimationOptions || {};
    if (!this._animators[this._animation]) {
      util_default.throw("No such animation: " + this._animation);
    }
  }
  /**
   * @param {String} jsonString
   * @return {Object/null}
   */
  static parseAnimationOptionsString(jsonString) {
    try {
      if (typeof jsonString === "string") {
        const result = util_default.animationOptionsParse(jsonString);
        if (typeof result === "object" && result !== null) {
          return result;
        } else {
          console.error('"animation-options" attribute must be a JSON object string: ' + jsonString);
        }
      }
      return {};
    } catch (e) {
      console.error('"animation-options" attribute must be a JSON object string: ' + jsonString);
      return {};
    }
  }
  /**
   * @param {Object} options
   */
  setAnimationOptions(options) {
    this._animationOptions = options;
  }
  /**
   * @param {Object} options
   * @param {String} [options.animation] The animation name
   * @param {Object} [options.animationOptions] The animation options
   * @param {Object} defaultAnimator The default animator instance
   * @return {Object} An animator instance
   */
  newAnimator(options = {}, defaultAnimator) {
    let animator = null;
    if (options.animation instanceof this._baseClass) {
      return options.animation;
    }
    let Animator = null;
    if (typeof options.animation === "string") {
      Animator = this._animators[options.animation];
    }
    if (!Animator && defaultAnimator) {
      animator = defaultAnimator;
    } else {
      Animator = Animator || this._animators[this._animation];
      const animationOpts = util_default.extend(
        {},
        this._animationOptions,
        options.animationOptions || {},
        internal_default.config.animationsDisabled ? { duration: 0, delay: 0 } : {}
      );
      animator = new Animator(animationOpts);
      if (typeof animator === "function") {
        animator = new animator(animationOpts);
      }
    }
    if (!(animator instanceof this._baseClass)) {
      util_default.throw(`"animator" is not an instance of ${this._baseClassName}`);
    }
    return animator;
  }
};

// node_modules/onsenui/esm/ons/internal/device-back-button-dispatcher.js
var util2 = {
  _ready: false,
  _domContentLoaded: false,
  _onDOMContentLoaded: () => {
    util2._domContentLoaded = true;
    if (platform_default.isWebView()) {
      window.document.addEventListener("deviceready", () => {
        util2._ready = true;
      }, false);
    } else {
      util2._ready = true;
    }
  },
  addBackButtonListener: function(fn) {
    if (!this._domContentLoaded) {
      throw new Error("This method is available after DOMContentLoaded");
    }
    if (this._ready) {
      window.document.addEventListener("backbutton", fn, false);
    } else {
      window.document.addEventListener("deviceready", function() {
        window.document.addEventListener("backbutton", fn, false);
      });
    }
  },
  removeBackButtonListener: function(fn) {
    if (!this._domContentLoaded) {
      throw new Error("This method is available after DOMContentLoaded");
    }
    if (this._ready) {
      window.document.removeEventListener("backbutton", fn, false);
    } else {
      window.document.addEventListener("deviceready", function() {
        window.document.removeEventListener("backbutton", fn, false);
      });
    }
  }
};
window.addEventListener("DOMContentLoaded", () => util2._onDOMContentLoaded(), false);
var HandlerRepository = {
  _store: {},
  _genId: (() => {
    let i = 0;
    return () => i++;
  })(),
  set: function(element, handler) {
    if (element.dataset.deviceBackButtonHandlerId) {
      this.remove(element);
    }
    const id = element.dataset.deviceBackButtonHandlerId = HandlerRepository._genId();
    this._store[id] = handler;
  },
  remove: function(element) {
    if (element.dataset.deviceBackButtonHandlerId) {
      delete this._store[element.dataset.deviceBackButtonHandlerId];
      delete element.dataset.deviceBackButtonHandlerId;
    }
  },
  get: function(element) {
    if (!element.dataset.deviceBackButtonHandlerId) {
      return void 0;
    }
    const id = element.dataset.deviceBackButtonHandlerId;
    if (!this._store[id]) {
      throw new Error();
    }
    return this._store[id];
  },
  has: function(element) {
    if (!element.dataset) {
      return false;
    }
    const id = element.dataset.deviceBackButtonHandlerId;
    return !!this._store[id];
  }
};
var DeviceBackButtonDispatcher = class {
  constructor() {
    this._isEnabled = false;
    this._boundCallback = this._callback.bind(this);
  }
  /**
   * Enable to handle 'backbutton' events.
   */
  enable() {
    if (!this._isEnabled) {
      util2.addBackButtonListener(this._boundCallback);
      this._isEnabled = true;
    }
  }
  /**
   * Disable to handle 'backbutton' events.
   */
  disable() {
    if (this._isEnabled) {
      util2.removeBackButtonListener(this._boundCallback);
      this._isEnabled = false;
    }
  }
  /**
   * Fire a 'backbutton' event manually.
   */
  fireDeviceBackButtonEvent() {
    const event = document.createEvent("Event");
    event.initEvent("backbutton", true, true);
    document.dispatchEvent(event);
  }
  _callback() {
    this._dispatchDeviceBackButtonEvent();
  }
  /**
   * @param {HTMLElement} element
   * @param {Function} callback
   */
  createHandler(element, callback) {
    if (!(element instanceof HTMLElement)) {
      throw new Error("element must be an instance of HTMLElement");
    }
    if (!(callback instanceof Function)) {
      throw new Error("callback must be an instance of Function");
    }
    const handler = {
      _callback: callback,
      _element: element,
      disable: function() {
        HandlerRepository.remove(element);
      },
      setListener: function(callback2) {
        this._callback = callback2;
      },
      enable: function() {
        HandlerRepository.set(element, this);
      },
      isEnabled: function() {
        return HandlerRepository.get(element) === this;
      },
      destroy: function() {
        HandlerRepository.remove(element);
        this._callback = this._element = null;
      }
    };
    handler.enable();
    return handler;
  }
  _dispatchDeviceBackButtonEvent() {
    const tree = this._captureTree();
    const element = this._findHandlerLeafElement(tree);
    let handler = HandlerRepository.get(element);
    handler._callback(createEvent(element));
    function createEvent(element2) {
      return {
        _element: element2,
        callParentHandler: function() {
          let parent = this._element.parentNode;
          while (parent) {
            handler = HandlerRepository.get(parent);
            if (handler) {
              return handler._callback(createEvent(parent));
            }
            parent = parent.parentNode;
          }
        }
      };
    }
  }
  /**
   * @return {Object}
   */
  _captureTree() {
    return createTree(document.body);
    function createTree(element) {
      const tree = {
        element,
        children: Array.prototype.concat.apply([], arrayOf(element.children).map(function(childElement) {
          if (childElement.style.display === "none" || childElement._isShown === false) {
            return [];
          }
          if (childElement.children.length === 0 && !HandlerRepository.has(childElement)) {
            return [];
          }
          const result = createTree(childElement);
          if (result.children.length === 0 && !HandlerRepository.has(result.element)) {
            return [];
          }
          return [result];
        }))
      };
      if (!HandlerRepository.has(tree.element)) {
        for (let i = 0; i < tree.children.length; i++) {
          const subTree = tree.children[i];
          if (HandlerRepository.has(subTree.element)) {
            return subTree;
          }
        }
      }
      return tree;
    }
    function arrayOf(target) {
      const result = [];
      for (let i = 0; i < target.length; i++) {
        result.push(target[i]);
      }
      return result;
    }
  }
  /**
   * @param {Object} tree
   * @return {HTMLElement}
   */
  _findHandlerLeafElement(tree) {
    return find(tree);
    function find(node) {
      if (node.children.length === 0) {
        return node.element;
      }
      if (node.children.length === 1) {
        return find(node.children[0]);
      }
      return node.children.map(function(childNode) {
        return childNode.element;
      }).reduce(function(left, right) {
        if (!left) {
          return right;
        }
        const leftZ = parseInt(window.getComputedStyle(left, "").zIndex, 10);
        const rightZ = parseInt(window.getComputedStyle(right, "").zIndex, 10);
        if (!isNaN(leftZ) && !isNaN(rightZ)) {
          return leftZ > rightZ ? left : right;
        }
        throw new Error("Capturing backbutton-handler is failure.");
      }, null);
    }
  }
};
var device_back_button_dispatcher_default = new DeviceBackButtonDispatcher();

// node_modules/onsenui/esm/ons/internal/index.js
internal_default2.AnimatorFactory = AnimatorFactory;
internal_default2.ModifierUtil = ModifierUtil;
internal_default2.dbbDispatcher = device_back_button_dispatcher_default;
var internal_default = internal_default2;

// node_modules/onsenui/esm/setup.js
function setup(ons2) {
  internal_default.waitDOMContentLoaded(function() {
    register2('script[type="text/template"]');
    register2('script[type="text/ng-template"]');
    register2("template");
    function register2(query) {
      const templates = window.document.querySelectorAll(query);
      for (let i = 0; i < templates.length; i++) {
        internal_default.templateStore.set(templates[i].getAttribute("id"), templates[i].textContent || templates[i].content);
      }
    }
  });
  if (window._onsLoaded) {
    ons2._util.warn("Onsen UI is loaded more than once.");
  }
  window._onsLoaded = true;
  ons2.ready(function() {
    ons2.enableDeviceBackButtonHandler();
    ons2._defaultDeviceBackButtonHandler = ons2._internal.dbbDispatcher.createHandler(window.document.body, () => {
      if (Object.hasOwnProperty.call(navigator, "app")) {
        navigator.app.exitApp();
      } else {
        console.warn("Could not close the app. Is 'cordova.js' included?\nError: 'window.navigator.app' is undefined.");
      }
    });
    document.body._gestureDetector = new ons2.GestureDetector(document.body, { passive: true });
    if (!ons2.platform.isWebView()) {
      document.body.addEventListener("keydown", function(event) {
        if (event.keyCode === 27) {
          ons2.fireDeviceBackButtonEvent();
        }
      });
    }
    ons2._setupLoadingPlaceHolders();
  });
  Viewport.setup();
}

// node_modules/onsenui/esm/ons/animit.js
var TIMEOUT_RATIO = 1.4;
var util3 = {};
util3.capitalize = function(str) {
  return str.charAt(0).toUpperCase() + str.slice(1);
};
util3.buildTransitionValue = function(params) {
  params.property = params.property || "all";
  params.duration = params.duration || 0.4;
  params.timing = params.timing || "linear";
  var props = params.property.split(/ +/);
  return props.map(function(prop) {
    return prop + " " + params.duration + "s " + params.timing;
  }).join(", ");
};
util3.onceOnTransitionEnd = function(element, callback) {
  if (!element) {
    return function() {
    };
  }
  var removeListeners = function() {
    util3._transitionEndEvents.forEach(function(eventName) {
      element.removeEventListener(eventName, fn, false);
    });
  };
  var fn = function(event) {
    if (element == event.target) {
      event.stopPropagation();
      removeListeners();
      callback();
    }
  };
  util3._transitionEndEvents.forEach(function(eventName) {
    element.addEventListener(eventName, fn, false);
  });
  return removeListeners;
};
util3._transitionEndEvents = function() {
  if ("ontransitionend" in window) {
    return ["transitionend"];
  }
  if ("onwebkittransitionend" in window) {
    return ["webkitTransitionEnd"];
  }
  if (util3.vendorPrefix === "webkit" || util3.vendorPrefix === "o" || util3.vendorPrefix === "moz" || util3.vendorPrefix === "ms") {
    return [util3.vendorPrefix + "TransitionEnd", "transitionend"];
  }
  return [];
}();
util3._cssPropertyDict = function() {
  var styles = window.getComputedStyle(document.documentElement, "");
  var dict = {};
  var a = "A".charCodeAt(0);
  var z = "z".charCodeAt(0);
  var upper = function(s) {
    return s.substr(1).toUpperCase();
  };
  for (var i = 0; i < styles.length; i++) {
    var key = styles[i].replace(/^[-]+/, "").replace(/[-][a-z]/g, upper).replace(/^moz/, "Moz");
    if (a <= key.charCodeAt(0) && z >= key.charCodeAt(0)) {
      if (key !== "cssText" && key !== "parentText") {
        dict[key] = true;
      }
    }
  }
  return dict;
}();
util3.hasCssProperty = function(name) {
  return name in util3._cssPropertyDict;
};
util3.vendorPrefix = function() {
  var styles = window.getComputedStyle(document.documentElement, ""), pre = (Array.prototype.slice.call(styles).join("").match(/-(moz|webkit|ms)-/) || styles.OLink === "" && ["", "o"])[1];
  return pre;
}();
util3.forceLayoutAtOnce = function(elements, callback) {
  this.batchImmediate(function() {
    elements.forEach(function(element) {
      element.offsetHeight;
    });
    callback();
  });
};
util3.batchImmediate = function() {
  var callbacks = [];
  return function(callback) {
    if (callbacks.length === 0) {
      setImmediate(function() {
        var concreateCallbacks = callbacks.slice(0);
        callbacks = [];
        concreateCallbacks.forEach(function(callback2) {
          callback2();
        });
      });
    }
    callbacks.push(callback);
  };
}();
util3.batchAnimationFrame = function() {
  var callbacks = [];
  var raf = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function(callback) {
    setTimeout(callback, 1e3 / 60);
  };
  return function(callback) {
    if (callbacks.length === 0) {
      raf(function() {
        var concreateCallbacks = callbacks.slice(0);
        callbacks = [];
        concreateCallbacks.forEach(function(callback2) {
          callback2();
        });
      });
    }
    callbacks.push(callback);
  };
}();
util3.transitionPropertyName = function() {
  if (util3.hasCssProperty("transitionDuration")) {
    return "transition";
  }
  if (util3.hasCssProperty(util3.vendorPrefix + "TransitionDuration")) {
    return util3.vendorPrefix + "Transition";
  }
  throw new Error("Invalid state");
}();
var Animit = function(element, defaults) {
  if (!(this instanceof Animit)) {
    return new Animit(element, defaults);
  }
  if (element instanceof HTMLElement) {
    this.elements = [element];
  } else if (Object.prototype.toString.call(element) === "[object Array]") {
    this.elements = element;
  } else {
    throw new Error("First argument must be an array or an instance of HTMLElement.");
  }
  this.defaults = defaults;
  this.transitionQueue = [];
  this.lastStyleAttributeDict = [];
};
Animit.prototype = {
  /**
   * @property {Array}
   */
  transitionQueue: void 0,
  /**
   * @property {Array}
   */
  elements: void 0,
  /**
   * @property {Object}
   */
  defaults: void 0,
  /**
   * Start animation sequence with passed animations.
   *
   * @param {Function} callback
   */
  play: function(callback) {
    if (typeof callback === "function") {
      this.transitionQueue.push(function(done) {
        callback();
        done();
      });
    }
    this.startAnimation();
    return this;
  },
  /**
   * Most of the animations follow this default process.
   *
   * @param {from} css or options object containing css
   * @param {to} css or options object containing css
   * @param {delay} delay to wait
   */
  default: function(from, to, delay) {
    function step(params, duration, timing) {
      if (params.duration !== void 0) {
        duration = params.duration;
      }
      if (params.timing !== void 0) {
        timing = params.timing;
      }
      return {
        css: params.css || params,
        duration,
        timing
      };
    }
    return this.saveStyle().queue(step(from, 0, this.defaults.timing)).wait(delay === void 0 ? this.defaults.delay : delay).queue(step(to, this.defaults.duration, this.defaults.timing)).restoreStyle();
  },
  /**
   * Queue transition animations or other function.
   *
   * e.g. animit(elt).queue({color: 'red'})
   * e.g. animit(elt).queue({color: 'red'}, {duration: 0.4})
   * e.g. animit(elt).queue({css: {color: 'red'}, duration: 0.2})
   *
   * @param {Object|Animit.Transition|Function} transition
   * @param {Object} [options]
   */
  queue: function(transition, options) {
    var queue = this.transitionQueue;
    if (transition && options) {
      options.css = transition;
      transition = new Animit.Transition(options);
    }
    if (!(transition instanceof Function || transition instanceof Animit.Transition)) {
      if (transition.css) {
        transition = new Animit.Transition(transition);
      } else {
        transition = new Animit.Transition({
          css: transition
        });
      }
    }
    if (transition instanceof Function) {
      queue.push(transition);
    } else if (transition instanceof Animit.Transition) {
      queue.push(transition.build());
    } else {
      throw new Error("Invalid arguments");
    }
    return this;
  },
  /**
   * Queue transition animations.
   *
   * @param {Float} seconds
   */
  wait: function(seconds) {
    if (seconds > 0) {
      this.transitionQueue.push(function(done) {
        setTimeout(done, 1e3 * seconds);
      });
    }
    return this;
  },
  saveStyle: function() {
    this.transitionQueue.push((function(done) {
      this.elements.forEach((function(element, index) {
        var css = this.lastStyleAttributeDict[index] = {};
        for (var i = 0; i < element.style.length; i++) {
          css[element.style[i]] = element.style[element.style[i]];
        }
      }).bind(this));
      done();
    }).bind(this));
    return this;
  },
  /**
   * Restore element's style.
   *
   * @param {Object} [options]
   * @param {Float} [options.duration]
   * @param {String} [options.timing]
   * @param {String} [options.transition]
   */
  restoreStyle: function(options) {
    options = options || {};
    var self2 = this;
    if (options.transition && !options.duration) {
      throw new Error('"options.duration" is required when "options.transition" is enabled.');
    }
    var transitionName = util3.transitionPropertyName;
    if (options.transition || options.duration && options.duration > 0) {
      var transitionValue = options.transition || "all " + options.duration + "s " + (options.timing || "linear");
      this.transitionQueue.push(function(done) {
        var elements = this.elements;
        var timeoutId;
        var clearTransition = function() {
          elements.forEach(function(element) {
            element.style[transitionName] = "";
          });
        };
        var removeListeners = util3.onceOnTransitionEnd(elements[0], function() {
          clearTimeout(timeoutId);
          clearTransition();
          done();
        });
        timeoutId = setTimeout(function() {
          removeListeners();
          clearTransition();
          done();
        }, options.duration * 1e3 * TIMEOUT_RATIO);
        elements.forEach(function(element, index) {
          var css = self2.lastStyleAttributeDict[index];
          if (!css) {
            throw new Error("restoreStyle(): The style is not saved. Invoke saveStyle() before.");
          }
          self2.lastStyleAttributeDict[index] = void 0;
          var name;
          for (var i = 0, len = element.style.length; i < len; i++) {
            name = element.style[i];
            if (css[name] === void 0) {
              css[name] = "";
            }
          }
          element.style[transitionName] = transitionValue;
          Object.keys(css).forEach(function(key) {
            if (key !== transitionName) {
              element.style[key] = css[key];
            }
          });
          element.style[transitionName] = transitionValue;
        });
      });
    } else {
      this.transitionQueue.push(function(done) {
        reset();
        done();
      });
    }
    return this;
    function reset() {
      self2.elements.forEach(function(element, index) {
        element.style[transitionName] = "none";
        var css = self2.lastStyleAttributeDict[index];
        if (!css) {
          throw new Error("restoreStyle(): The style is not saved. Invoke saveStyle() before.");
        }
        self2.lastStyleAttributeDict[index] = void 0;
        for (var i = 0, name = ""; i < element.style.length; i++) {
          name = element.style[i];
          if (typeof css[element.style[i]] === "undefined") {
            css[element.style[i]] = "";
          }
        }
        Object.keys(css).forEach(function(key) {
          element.style[key] = css[key];
        });
      });
    }
  },
  /**
   * Start animation sequence.
   */
  startAnimation: function() {
    this._dequeueTransition();
    return this;
  },
  _dequeueTransition: function() {
    var transition = this.transitionQueue.shift();
    if (this._currentTransition) {
      throw new Error("Current transition exists.");
    }
    this._currentTransition = transition;
    var self2 = this;
    var called = false;
    var done = function() {
      if (!called) {
        called = true;
        self2._currentTransition = void 0;
        self2._dequeueTransition();
      } else {
        throw new Error("Invalid state: This callback is called twice.");
      }
    };
    if (transition) {
      transition.call(this, done);
    }
  }
};
Animit.runAll = function() {
  for (var i = 0; i < arguments.length; i++) {
    arguments[i].play();
  }
};
Animit.Transition = function(options) {
  this.options = options || {};
  this.options.duration = this.options.duration || 0;
  this.options.timing = this.options.timing || "linear";
  this.options.css = this.options.css || {};
  this.options.property = this.options.property || "all";
};
Animit.Transition.prototype = {
  /**
   * @param {HTMLElement} element
   * @return {Function}
   */
  build: function() {
    if (Object.keys(this.options.css).length === 0) {
      throw new Error("options.css is required.");
    }
    var css = createActualCssProps(this.options.css);
    if (this.options.duration > 0) {
      var transitionValue = util3.buildTransitionValue(this.options);
      var self2 = this;
      return function(callback) {
        var elements = this.elements;
        var timeout = self2.options.duration * 1e3 * TIMEOUT_RATIO;
        var timeoutId;
        var removeListeners = util3.onceOnTransitionEnd(elements[0], function() {
          clearTimeout(timeoutId);
          callback();
        });
        timeoutId = setTimeout(function() {
          removeListeners();
          callback();
        }, timeout);
        elements.forEach(function(element) {
          element.style[util3.transitionPropertyName] = transitionValue;
          Object.keys(css).forEach(function(name) {
            element.style[name] = css[name];
          });
        });
      };
    }
    if (this.options.duration <= 0) {
      return function(callback) {
        var elements = this.elements;
        elements.forEach(function(element) {
          element.style[util3.transitionPropertyName] = "";
          Object.keys(css).forEach(function(name) {
            element.style[name] = css[name];
          });
        });
        if (elements.length > 0) {
          util3.forceLayoutAtOnce(elements, function() {
            util3.batchAnimationFrame(callback);
          });
        } else {
          util3.batchAnimationFrame(callback);
        }
      };
    }
    function createActualCssProps(css2) {
      var result = {};
      Object.keys(css2).forEach(function(name) {
        var value = css2[name];
        if (util3.hasCssProperty(name)) {
          result[name] = value;
          return;
        }
        var prefixed = util3.vendorPrefix + util3.capitalize(name);
        if (util3.hasCssProperty(prefixed)) {
          result[prefixed] = value;
        } else {
          result[prefixed] = value;
          result[name] = value;
        }
      });
      return result;
    }
  }
};
var animit_default = Animit;

// node_modules/onsenui/esm/ons/gesture-detector.js
var Event;
var Utils;
var Detection;
var PointerEvent;
var GestureDetector = function GestureDetector2(element, options) {
  return new GestureDetector2.Instance(element, options || {});
};
GestureDetector.defaults = {
  behavior: {
    // userSelect: 'none', // Also disables selection in `input` children
    touchAction: "pan-y",
    touchCallout: "none",
    contentZooming: "none",
    userDrag: "none",
    tapHighlightColor: "rgba(0,0,0,0)"
  }
};
GestureDetector.DOCUMENT = document;
GestureDetector.HAS_POINTEREVENTS = navigator.pointerEnabled || navigator.msPointerEnabled;
GestureDetector.HAS_TOUCHEVENTS = "ontouchstart" in window;
GestureDetector.IS_MOBILE = /mobile|tablet|ip(ad|hone|od)|android|silk/i.test(navigator.userAgent);
GestureDetector.NO_MOUSEEVENTS = GestureDetector.HAS_TOUCHEVENTS && GestureDetector.IS_MOBILE || GestureDetector.HAS_POINTEREVENTS;
GestureDetector.CALCULATE_INTERVAL = 25;
var EVENT_TYPES = {};
var DIRECTION_DOWN = GestureDetector.DIRECTION_DOWN = "down";
var DIRECTION_LEFT = GestureDetector.DIRECTION_LEFT = "left";
var DIRECTION_UP = GestureDetector.DIRECTION_UP = "up";
var DIRECTION_RIGHT = GestureDetector.DIRECTION_RIGHT = "right";
var POINTER_MOUSE = GestureDetector.POINTER_MOUSE = "mouse";
var POINTER_TOUCH = GestureDetector.POINTER_TOUCH = "touch";
var POINTER_PEN = GestureDetector.POINTER_PEN = "pen";
var EVENT_START = GestureDetector.EVENT_START = "start";
var EVENT_MOVE = GestureDetector.EVENT_MOVE = "move";
var EVENT_END = GestureDetector.EVENT_END = "end";
var EVENT_RELEASE = GestureDetector.EVENT_RELEASE = "release";
var EVENT_TOUCH = GestureDetector.EVENT_TOUCH = "touch";
GestureDetector.READY = false;
GestureDetector.plugins = GestureDetector.plugins || {};
GestureDetector.gestures = GestureDetector.gestures || {};
function setup2(opts) {
  if (GestureDetector.READY) {
    return;
  }
  Event.determineEventTypes();
  Utils.each(GestureDetector.gestures, function(gesture) {
    Detection.register(gesture);
  });
  Event.onTouch(GestureDetector.DOCUMENT, EVENT_MOVE, Detection.detect, opts);
  Event.onTouch(GestureDetector.DOCUMENT, EVENT_END, Detection.detect, opts);
  GestureDetector.READY = true;
}
Utils = GestureDetector.utils = {
  /**
   * extend method, could also be used for cloning when `dest` is an empty object.
   * changes the dest object
   * @param {Object} dest
   * @param {Object} src
   * @param {Boolean} [merge=false]  do a merge
   * @return {Object} dest
   */
  extend: function extend(dest, src, merge) {
    for (var key in src) {
      if (Object.prototype.hasOwnProperty.call(src, key) && (dest[key] === void 0 || !merge)) {
        dest[key] = src[key];
      }
    }
    return dest;
  },
  /**
   * simple addEventListener wrapper
   * @param {HTMLElement} element
   * @param {String} type
   * @param {Function} handler
   */
  on: function on(element, type, handler, opt) {
    util_default.addEventListener(element, type, handler, opt, true);
  },
  /**
   * simple removeEventListener wrapper
   * @param {HTMLElement} element
   * @param {String} type
   * @param {Function} handler
   */
  off: function off(element, type, handler, opt) {
    util_default.removeEventListener(element, type, handler, opt, true);
  },
  /**
   * forEach over arrays and objects
   * @param {Object|Array} obj
   * @param {Function} iterator
   * @param {any} iterator.item
   * @param {Number} iterator.index
   * @param {Object|Array} iterator.obj the source object
   * @param {Object} context value to use as `this` in the iterator
   */
  each: function each(obj, iterator, context) {
    var i, len;
    if ("forEach" in obj) {
      obj.forEach(iterator, context);
    } else if (obj.length !== void 0) {
      for (i = 0, len = obj.length; i < len; i++) {
        if (iterator.call(context, obj[i], i, obj) === false) {
          return;
        }
      }
    } else {
      for (i in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, i) && iterator.call(context, obj[i], i, obj) === false) {
          return;
        }
      }
    }
  },
  /**
   * find if a string contains the string using indexOf
   * @param {String} src
   * @param {String} find
   * @return {Boolean} found
   */
  inStr: function inStr(src, find) {
    return src.indexOf(find) > -1;
  },
  /**
   * find if a array contains the object using indexOf or a simple polyfill
   * @param {String} src
   * @param {String} find
   * @return {Boolean|Number} false when not found, or the index
   */
  inArray: function inArray(src, find, deep) {
    if (deep) {
      for (var i = 0, len = src.length; i < len; i++) {
        if (Object.keys(find).every(function(key) {
          return src[i][key] === find[key];
        })) {
          return i;
        }
      }
      return -1;
    }
    if (src.indexOf) {
      return src.indexOf(find);
    } else {
      for (var i = 0, len = src.length; i < len; i++) {
        if (src[i] === find) {
          return i;
        }
      }
      return -1;
    }
  },
  /**
   * convert an array-like object (`arguments`, `touchlist`) to an array
   * @param {Object} obj
   * @return {Array}
   */
  toArray: function toArray(obj) {
    return Array.prototype.slice.call(obj, 0);
  },
  /**
   * find if a node is in the given parent
   * @param {HTMLElement} node
   * @param {HTMLElement} parent
   * @return {Boolean} found
   */
  hasParent: function hasParent(node, parent) {
    while (node) {
      if (node == parent) {
        return true;
      }
      node = node.parentNode;
    }
    return false;
  },
  /**
   * get the center of all the touches
   * @param {Array} touches
   * @return {Object} center contains `pageX`, `pageY`, `clientX` and `clientY` properties
   */
  getCenter: function getCenter(touches) {
    var pageX = [], pageY = [], clientX = [], clientY = [], min = Math.min, max = Math.max;
    if (touches.length === 1) {
      return {
        pageX: touches[0].pageX,
        pageY: touches[0].pageY,
        clientX: touches[0].clientX,
        clientY: touches[0].clientY
      };
    }
    Utils.each(touches, function(touch) {
      pageX.push(touch.pageX);
      pageY.push(touch.pageY);
      clientX.push(touch.clientX);
      clientY.push(touch.clientY);
    });
    return {
      pageX: (min.apply(Math, pageX) + max.apply(Math, pageX)) / 2,
      pageY: (min.apply(Math, pageY) + max.apply(Math, pageY)) / 2,
      clientX: (min.apply(Math, clientX) + max.apply(Math, clientX)) / 2,
      clientY: (min.apply(Math, clientY) + max.apply(Math, clientY)) / 2
    };
  },
  /**
   * calculate the velocity between two points. unit is in px per ms.
   * @param {Number} deltaTime
   * @param {Number} deltaX
   * @param {Number} deltaY
   * @return {Object} velocity `x` and `y`
   */
  getVelocity: function getVelocity(deltaTime, deltaX, deltaY) {
    return {
      x: Math.abs(deltaX / deltaTime) || 0,
      y: Math.abs(deltaY / deltaTime) || 0
    };
  },
  /**
   * calculate the angle between two coordinates
   * @param {Touch} touch1
   * @param {Touch} touch2
   * @return {Number} angle
   */
  getAngle: function getAngle(touch1, touch2) {
    var x = touch2.clientX - touch1.clientX, y = touch2.clientY - touch1.clientY;
    return Math.atan2(y, x) * 180 / Math.PI;
  },
  /**
   * do a small comparison to get the direction between two touches.
   * @param {Touch} touch1
   * @param {Touch} touch2
   * @return {String} direction matches `DIRECTION_LEFT|RIGHT|UP|DOWN`
   */
  getDirection: function getDirection(touch1, touch2) {
    var x = Math.abs(touch1.clientX - touch2.clientX), y = Math.abs(touch1.clientY - touch2.clientY);
    if (x >= y) {
      return touch1.clientX - touch2.clientX > 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;
    }
    return touch1.clientY - touch2.clientY > 0 ? DIRECTION_UP : DIRECTION_DOWN;
  },
  /**
   * calculate the distance between two touches
   * @param {Touch}touch1
   * @param {Touch} touch2
   * @return {Number} distance
   */
  getDistance: function getDistance(touch1, touch2) {
    var x = touch2.clientX - touch1.clientX, y = touch2.clientY - touch1.clientY;
    return Math.sqrt(x * x + y * y);
  },
  /**
   * calculate the scale factor between two touchLists
   * no scale is 1, and goes down to 0 when pinched together, and bigger when pinched out
   * @param {Array} start array of touches
   * @param {Array} end array of touches
   * @return {Number} scale
   */
  getScale: function getScale(start, end) {
    if (start.length >= 2 && end.length >= 2) {
      return this.getDistance(end[0], end[1]) / this.getDistance(start[0], start[1]);
    }
    return 1;
  },
  /**
   * calculate the rotation degrees between two touchLists
   * @param {Array} start array of touches
   * @param {Array} end array of touches
   * @return {Number} rotation
   */
  getRotation: function getRotation(start, end) {
    if (start.length >= 2 && end.length >= 2) {
      return this.getAngle(end[1], end[0]) - this.getAngle(start[1], start[0]);
    }
    return 0;
  },
  /**
   * find out if the direction is vertical   *
   * @param {String} direction matches `DIRECTION_UP|DOWN`
   * @return {Boolean} is_vertical
   */
  isVertical: function isVertical(direction) {
    return direction == DIRECTION_UP || direction == DIRECTION_DOWN;
  },
  /**
   * set css properties with their prefixes
   * @param {HTMLElement} element
   * @param {String} prop
   * @param {String} value
   * @param {Boolean} [toggle=true]
   * @return {Boolean}
   */
  setPrefixedCss: function setPrefixedCss(element, prop, value, toggle) {
    var prefixes = ["", "Webkit", "Moz", "O", "ms"];
    prop = Utils.toCamelCase(prop);
    for (var i = 0; i < prefixes.length; i++) {
      var p = prop;
      if (prefixes[i]) {
        p = prefixes[i] + p.slice(0, 1).toUpperCase() + p.slice(1);
      }
      if (p in element.style) {
        element.style[p] = (toggle === null || toggle) && value || "";
        break;
      }
    }
  },
  /**
   * toggle browser default behavior by setting css properties.
   * `userSelect='none'` also sets `element.onselectstart` to false
   * `userDrag='none'` also sets `element.ondragstart` to false
   *
   * @param {HtmlElement} element
   * @param {Object} props
   * @param {Boolean} [toggle=true]
   */
  toggleBehavior: function toggleBehavior(element, props, toggle) {
    if (!props || !element || !element.style) {
      return;
    }
    Utils.each(props, function(value, prop) {
      Utils.setPrefixedCss(element, prop, value, toggle);
    });
    var falseFn = toggle && function() {
      return false;
    };
    if (props.userSelect == "none") {
      element.onselectstart = falseFn;
    }
    if (props.userDrag == "none") {
      element.ondragstart = falseFn;
    }
  },
  /**
   * convert a string with underscores to camelCase
   * so prevent_default becomes preventDefault
   * @param {String} str
   * @return {String} camelCaseStr
   */
  toCamelCase: function toCamelCase(str) {
    return str.replace(/[_-]([a-z])/g, function(s) {
      return s[1].toUpperCase();
    });
  }
};
Event = GestureDetector.event = {
  /**
   * when touch events have been fired, this is true
   * this is used to stop mouse events
   * @property prevent_mouseevents
   * @private
   * @type {Boolean}
   */
  preventMouseEvents: false,
  /**
   * if EVENT_START has been fired
   * @property started
   * @private
   * @type {Boolean}
   */
  started: false,
  /**
   * when the mouse is hold down, this is true
   * @property should_detect
   * @private
   * @type {Boolean}
   */
  shouldDetect: false,
  /**
   * simple event binder with a hook and support for multiple types
   * @param {HTMLElement} element
   * @param {String} type
   * @param {Function} handler
   * @param {Object} [opt]
   * @param {Function} [hook]
   * @param {Object} hook.type
   */
  on: function on2(element, type, handler, opt, hook) {
    var types = type.split(" ");
    Utils.each(types, function(type2) {
      Utils.on(element, type2, handler, opt);
      hook && hook(type2);
    });
  },
  /**
   * simple event unbinder with a hook and support for multiple types
   * @param {HTMLElement} element
   * @param {String} type
   * @param {Function} handler
   * @param {Object} [opt]
   * @param {Function} [hook]
   * @param {Object} hook.type
   */
  off: function off2(element, type, handler, opt, hook) {
    var types = type.split(" ");
    Utils.each(types, function(type2) {
      Utils.off(element, type2, handler, opt);
      hook && hook(type2);
    });
  },
  /**
   * the core touch event handler.
   * this finds out if we should to detect gestures
   * @param {HTMLElement} element
   * @param {String} eventType matches `EVENT_START|MOVE|END`
   * @param {Function} handler
   * @return onTouchHandler {Function} the core event handler
   */
  onTouch: function onTouch(element, eventType, handler, opt) {
    var self2 = this;
    var onTouchHandler = function onTouchHandler2(ev) {
      var srcType = ev.type.toLowerCase(), isPointer = GestureDetector.HAS_POINTEREVENTS, isMouse = Utils.inStr(srcType, "mouse"), triggerType;
      if (isMouse && self2.preventMouseEvents) {
        return;
      } else if (isMouse && eventType == EVENT_START && ev.button === 0) {
        self2.preventMouseEvents = false;
        self2.shouldDetect = true;
      } else if (isPointer && eventType == EVENT_START) {
        self2.shouldDetect = ev.buttons === 1 || PointerEvent.matchType(POINTER_TOUCH, ev);
      } else if (!isMouse && eventType == EVENT_START) {
        self2.preventMouseEvents = true;
        self2.shouldDetect = true;
      }
      if (isPointer && eventType != EVENT_END) {
        PointerEvent.updatePointer(eventType, ev);
      }
      if (self2.shouldDetect) {
        triggerType = self2.doDetect.call(self2, ev, eventType, element, handler);
      }
      if (triggerType == EVENT_END) {
        self2.preventMouseEvents = false;
        self2.shouldDetect = false;
        PointerEvent.reset();
      }
      if (isPointer && eventType == EVENT_END) {
        PointerEvent.updatePointer(eventType, ev);
      }
    };
    this.on(element, EVENT_TYPES[eventType], onTouchHandler, opt);
    return onTouchHandler;
  },
  /**
   * the core detection method
   * this finds out what GestureDetector-touch-events to trigger
   * @param {Object} ev
   * @param {String} eventType matches `EVENT_START|MOVE|END`
   * @param {HTMLElement} element
   * @param {Function} handler
   * @return {String} triggerType matches `EVENT_START|MOVE|END`
   */
  doDetect: function doDetect(ev, eventType, element, handler) {
    var touchList = this.getTouchList(ev, eventType);
    var touchListLength = touchList.length;
    var triggerType = eventType;
    var triggerChange = touchList.trigger;
    var changedLength = touchListLength;
    if (eventType == EVENT_START) {
      triggerChange = EVENT_TOUCH;
    } else if (eventType == EVENT_END) {
      triggerChange = EVENT_RELEASE;
      changedLength = touchList.length - (ev.changedTouches ? ev.changedTouches.length : 1);
    }
    if (changedLength > 0 && this.started) {
      triggerType = EVENT_MOVE;
    }
    this.started = true;
    var evData = this.collectEventData(element, triggerType, touchList, ev);
    if (eventType != EVENT_END) {
      handler.call(Detection, evData);
    }
    if (triggerChange) {
      evData.changedLength = changedLength;
      evData.eventType = triggerChange;
      handler.call(Detection, evData);
      evData.eventType = triggerType;
      delete evData.changedLength;
    }
    if (triggerType == EVENT_END) {
      handler.call(Detection, evData);
      this.started = false;
    }
    return triggerType;
  },
  /**
   * we have different events for each device/browser
   * determine what we need and set them in the EVENT_TYPES constant
   * the `onTouch` method is bind to these properties.
   * @return {Object} events
   */
  determineEventTypes: function determineEventTypes() {
    var types;
    if (GestureDetector.HAS_POINTEREVENTS) {
      if (window.PointerEvent) {
        types = [
          "pointerdown",
          "pointermove",
          "pointerup pointercancel lostpointercapture"
        ];
      } else {
        types = [
          "MSPointerDown",
          "MSPointerMove",
          "MSPointerUp MSPointerCancel MSLostPointerCapture"
        ];
      }
    } else if (GestureDetector.NO_MOUSEEVENTS) {
      types = [
        "touchstart",
        "touchmove",
        "touchend touchcancel"
      ];
    } else {
      types = [
        "touchstart mousedown",
        "touchmove mousemove",
        "touchend touchcancel mouseup"
      ];
    }
    EVENT_TYPES[EVENT_START] = types[0];
    EVENT_TYPES[EVENT_MOVE] = types[1];
    EVENT_TYPES[EVENT_END] = types[2];
    return EVENT_TYPES;
  },
  /**
   * create touchList depending on the event
   * @param {Object} ev
   * @param {String} eventType
   * @return {Array} touches
   */
  getTouchList: function getTouchList(ev, eventType) {
    if (GestureDetector.HAS_POINTEREVENTS) {
      return PointerEvent.getTouchList();
    }
    if (ev.touches) {
      if (eventType == EVENT_MOVE) {
        return ev.touches;
      }
      var identifiers = [];
      var concat = [].concat(Utils.toArray(ev.touches), Utils.toArray(ev.changedTouches));
      var touchList = [];
      Utils.each(concat, function(touch) {
        if (Utils.inArray(identifiers, touch.identifier) === -1) {
          touchList.push(touch);
        }
        identifiers.push(touch.identifier);
      });
      return touchList;
    }
    ev.identifier = 1;
    return [ev];
  },
  /**
   * collect basic event data
   * @param {HTMLElement} element
   * @param {String} eventType matches `EVENT_START|MOVE|END`
   * @param {Array} touches
   * @param {Object} ev
   * @return {Object} ev
   */
  collectEventData: function collectEventData(element, eventType, touches, ev) {
    var pointerType = POINTER_TOUCH;
    if (Utils.inStr(ev.type, "mouse") || PointerEvent.matchType(POINTER_MOUSE, ev)) {
      pointerType = POINTER_MOUSE;
    } else if (PointerEvent.matchType(POINTER_PEN, ev)) {
      pointerType = POINTER_PEN;
    }
    return {
      center: Utils.getCenter(touches),
      timeStamp: Date.now(),
      target: ev.target,
      touches,
      eventType,
      pointerType,
      srcEvent: ev,
      /**
       * prevent the browser default actions
       * mostly used to disable scrolling of the browser
       */
      preventDefault: function() {
        var srcEvent = this.srcEvent;
        srcEvent.preventManipulation && srcEvent.preventManipulation();
        srcEvent.preventDefault && srcEvent.preventDefault();
      },
      /**
       * stop bubbling the event up to its parents
       */
      stopPropagation: function() {
        this.srcEvent.stopPropagation();
      },
      /**
       * immediately stop gesture detection
       * might be useful after a swipe was detected
       * @return {*}
       */
      stopDetect: function() {
        return Detection.stopDetect();
      }
    };
  }
};
PointerEvent = GestureDetector.PointerEvent = {
  /**
   * holds all pointers, by `identifier`
   * @property pointers
   * @type {Object}
   */
  pointers: {},
  /**
   * get the pointers as an array
   * @return {Array} touchlist
   */
  getTouchList: function getTouchList2() {
    var touchlist = [];
    Utils.each(this.pointers, function(pointer) {
      touchlist.push(pointer);
    });
    return touchlist;
  },
  /**
   * update the position of a pointer
   * @param {String} eventType matches `EVENT_START|MOVE|END`
   * @param {Object} pointerEvent
   */
  updatePointer: function updatePointer(eventType, pointerEvent) {
    if (eventType == EVENT_END || eventType != EVENT_END && pointerEvent.buttons !== 1) {
      delete this.pointers[pointerEvent.pointerId];
    } else {
      pointerEvent.identifier = pointerEvent.pointerId;
      this.pointers[pointerEvent.pointerId] = pointerEvent;
    }
  },
  /**
   * check if ev matches pointertype
   * @param {String} pointerType matches `POINTER_MOUSE|TOUCH|PEN`
   * @param {PointerEvent} ev
   */
  matchType: function matchType(pointerType, ev) {
    if (!ev.pointerType) {
      return false;
    }
    var pt = ev.pointerType, types = {};
    types[POINTER_MOUSE] = pt === (ev.MSPOINTER_TYPE_MOUSE || POINTER_MOUSE);
    types[POINTER_TOUCH] = pt === (ev.MSPOINTER_TYPE_TOUCH || POINTER_TOUCH);
    types[POINTER_PEN] = pt === (ev.MSPOINTER_TYPE_PEN || POINTER_PEN);
    return types[pointerType];
  },
  /**
   * reset the stored pointers
   */
  reset: function resetList() {
    this.pointers = {};
  }
};
Detection = GestureDetector.detection = {
  // contains all registered GestureDetector.gestures in the correct order
  gestures: [],
  // data of the current GestureDetector.gesture detection session
  current: null,
  // the previous GestureDetector.gesture session data
  // is a full clone of the previous gesture.current object
  previous: null,
  // when this becomes true, no gestures are fired
  stopped: false,
  /**
   * start GestureDetector.gesture detection
   * @param {GestureDetector.Instance} inst
   * @param {Object} eventData
   */
  startDetect: function startDetect(inst, eventData) {
    if (this.current) {
      return;
    }
    this.stopped = false;
    this.current = {
      inst,
      // reference to GestureDetectorInstance we're working for
      startEvent: Utils.extend({}, eventData),
      // start eventData for distances, timing etc
      lastEvent: false,
      // last eventData
      lastCalcEvent: false,
      // last eventData for calculations.
      futureCalcEvent: false,
      // last eventData for calculations.
      lastCalcData: {},
      // last lastCalcData
      name: ""
      // current gesture we're in/detected, can be 'tap', 'hold' etc
    };
    this.detect(eventData);
  },
  /**
   * GestureDetector.gesture detection
   * @param {Object} eventData
   * @return {any}
   */
  detect: function detect(eventData) {
    if (!this.current || this.stopped) {
      return;
    }
    eventData = this.extendEventData(eventData);
    var inst = this.current.inst, instOptions = inst.options;
    Utils.each(this.gestures, function triggerGesture(gesture) {
      if (!this.stopped && inst.enabled && instOptions[gesture.name]) {
        gesture.handler.call(gesture, eventData, inst);
      }
    }, this);
    if (this.current) {
      this.current.lastEvent = eventData;
    }
    if (eventData.eventType == EVENT_END) {
      this.stopDetect();
    }
    return eventData;
  },
  /**
   * clear the GestureDetector.gesture vars
   * this is called on endDetect, but can also be used when a final GestureDetector.gesture has been detected
   * to stop other GestureDetector.gestures from being fired
   */
  stopDetect: function stopDetect() {
    this.previous = Utils.extend({}, this.current);
    this.current = null;
    this.stopped = true;
  },
  /**
   * calculate velocity, angle and direction
   * @param {Object} ev
   * @param {Object} center
   * @param {Number} deltaTime
   * @param {Number} deltaX
   * @param {Number} deltaY
   */
  getCalculatedData: function getCalculatedData(ev, center, deltaTime, deltaX, deltaY) {
    var cur = this.current, recalc = false, calcEv = cur.lastCalcEvent, calcData = cur.lastCalcData;
    if (calcEv && ev.timeStamp - calcEv.timeStamp > GestureDetector.CALCULATE_INTERVAL) {
      center = calcEv.center;
      deltaTime = ev.timeStamp - calcEv.timeStamp;
      deltaX = ev.center.clientX - calcEv.center.clientX;
      deltaY = ev.center.clientY - calcEv.center.clientY;
      recalc = true;
    }
    if (ev.eventType == EVENT_TOUCH || ev.eventType == EVENT_RELEASE) {
      cur.futureCalcEvent = ev;
    }
    if (!cur.lastCalcEvent || recalc) {
      calcData.velocity = Utils.getVelocity(deltaTime, deltaX, deltaY);
      calcData.angle = Utils.getAngle(center, ev.center);
      calcData.direction = Utils.getDirection(center, ev.center);
      cur.lastCalcEvent = cur.futureCalcEvent || ev;
      cur.futureCalcEvent = ev;
    }
    ev.velocityX = calcData.velocity.x;
    ev.velocityY = calcData.velocity.y;
    ev.interimAngle = calcData.angle;
    ev.interimDirection = calcData.direction;
  },
  /**
   * extend eventData for GestureDetector.gestures
   * @param {Object} ev
   * @return {Object} ev
   */
  extendEventData: function extendEventData(ev) {
    var cur = this.current, startEv = cur.startEvent, lastEv = cur.lastEvent || startEv;
    if (ev.eventType == EVENT_TOUCH || ev.eventType == EVENT_RELEASE) {
      startEv.touches = [];
      Utils.each(ev.touches, function(touch) {
        startEv.touches.push({
          clientX: touch.clientX,
          clientY: touch.clientY
        });
      });
    }
    var deltaTime = ev.timeStamp - startEv.timeStamp, deltaX = ev.center.clientX - startEv.center.clientX, deltaY = ev.center.clientY - startEv.center.clientY;
    this.getCalculatedData(ev, lastEv.center, deltaTime, deltaX, deltaY);
    Utils.extend(ev, {
      startEvent: startEv,
      deltaTime,
      deltaX,
      deltaY,
      distance: Utils.getDistance(startEv.center, ev.center),
      angle: Utils.getAngle(startEv.center, ev.center),
      direction: Utils.getDirection(startEv.center, ev.center),
      scale: Utils.getScale(startEv.touches, ev.touches),
      rotation: Utils.getRotation(startEv.touches, ev.touches)
    });
    return ev;
  },
  /**
   * register new gesture
   * @param {Object} gesture object, see `gestures/` for documentation
   * @return {Array} gestures
   */
  register: function register(gesture) {
    var options = gesture.defaults || {};
    if (options[gesture.name] === void 0) {
      options[gesture.name] = true;
    }
    Utils.extend(GestureDetector.defaults, options, true);
    gesture.index = gesture.index || 1e3;
    this.gestures.push(gesture);
    this.gestures.sort(function(a, b) {
      if (a.index < b.index) {
        return -1;
      }
      if (a.index > b.index) {
        return 1;
      }
      return 0;
    });
    return this.gestures;
  }
};
GestureDetector.Instance = function(element, options) {
  var self2 = this;
  var listenerOptions = options && options.passive ? { passive: true } : void 0;
  setup2(listenerOptions);
  this.element = element;
  this.enabled = true;
  Utils.each(options, function(value, name) {
    delete options[name];
    options[Utils.toCamelCase(name)] = value;
  });
  this.options = Utils.extend(Utils.extend({}, GestureDetector.defaults), options || {});
  this.options.listenerOptions = listenerOptions;
  if (this.options.behavior) {
    Utils.toggleBehavior(this.element, this.options.behavior, true);
  }
  this.eventStartHandler = Event.onTouch(element, EVENT_START, function(ev) {
    if (self2.enabled && ev.eventType == EVENT_START) {
      Detection.startDetect(self2, ev);
    } else if (ev.eventType == EVENT_TOUCH) {
      Detection.detect(ev);
    }
  }, listenerOptions);
  this.eventHandlers = [];
};
GestureDetector.Instance.prototype = {
  /**
   * @method on
   * @signature on(gestures, handler)
   * @description
   *  [en]Adds an event handler for a gesture. Available gestures are: drag, dragleft, dragright, dragup, dragdown, hold, release, swipe, swipeleft, swiperight, swipeup, swipedown, tap, doubletap, touch, transform, pinch, pinchin, pinchout and rotate. [/en]
   *  [ja]ジェスチャに対するイベントハンドラを追加します。指定できるジェスチャ名は、drag dragleft dragright dragup dragdown hold release swipe swipeleft swiperight swipeup swipedown tap doubletap touch transform pinch pinchin pinchout rotate です。[/ja]
   * @param {String} gestures
   *   [en]A space separated list of gestures.[/en]
   *   [ja]検知するジェスチャ名を指定します。スペースで複数指定することができます。[/ja]
   * @param {Function} handler
   *   [en]An event handling function.[/en]
   *   [ja]イベントハンドラとなる関数オブジェクトを指定します。[/ja]
   */
  on: function onEvent(gestures, handler, opt) {
    var self2 = this;
    Event.on(self2.element, gestures, handler, util_default.extend({}, self2.options.listenerOptions, opt), function(type) {
      self2.eventHandlers.push({ gesture: type, handler });
    });
    return self2;
  },
  /**
   * @method off
   * @signature off(gestures, handler)
   * @description
   *  [en]Remove an event listener.[/en]
   *  [ja]イベントリスナーを削除します。[/ja]
   * @param {String} gestures
   *   [en]A space separated list of gestures.[/en]
   *   [ja]ジェスチャ名を指定します。スペースで複数指定することができます。[/ja]
   * @param {Function} handler
   *   [en]An event handling function.[/en]
   *   [ja]イベントハンドラとなる関数オブジェクトを指定します。[/ja]
   */
  off: function offEvent(gestures, handler, opt) {
    var self2 = this;
    Event.off(self2.element, gestures, handler, util_default.extend({}, self2.options.listenerOptions, opt), function(type) {
      var index = Utils.inArray(self2.eventHandlers, { gesture: type, handler }, true);
      if (index >= 0) {
        self2.eventHandlers.splice(index, 1);
      }
    });
    return self2;
  },
  /**
   * trigger gesture event
   * @method trigger
   * @signature trigger(gesture, eventData)
   * @param {String} gesture
   * @param {Object} [eventData]
   */
  trigger: function triggerEvent(gesture, eventData) {
    if (!eventData) {
      eventData = {};
    }
    var event = GestureDetector.DOCUMENT.createEvent("Event");
    event.initEvent(gesture, true, true);
    event.gesture = eventData;
    var element = this.element;
    if (Utils.hasParent(eventData.target, element)) {
      element = eventData.target;
    }
    element.dispatchEvent(event);
    return this;
  },
  /**
   * @method enable
   * @signature enable(state)
   * @description
   *  [en]Enable or disable gesture detection.[/en]
   *  [ja]ジェスチャ検知を有効化/無効化します。[/ja]
   * @param {Boolean} state
   *   [en]Specify if it should be enabled or not.[/en]
   *   [ja]有効にするかどうかを指定します。[/ja]
   */
  enable: function enable(state) {
    this.enabled = state;
    return this;
  },
  /**
   * @method dispose
   * @signature dispose()
   * @description
   *  [en]Remove and destroy all event handlers for this instance.[/en]
   *  [ja]このインスタンスでのジェスチャの検知や、イベントハンドラを全て解除して廃棄します。[/ja]
   */
  dispose: function dispose() {
    var i, eh;
    Utils.toggleBehavior(this.element, this.options.behavior, false);
    for (i = -1; eh = this.eventHandlers[++i]; ) {
      Utils.off(this.element, eh.gesture, eh.handler);
    }
    this.eventHandlers = [];
    Event.off(this.element, EVENT_TYPES[EVENT_START], this.eventStartHandler);
    return null;
  }
};
(function(name) {
  var triggered = false;
  function dragGesture(ev, inst) {
    var cur = Detection.current;
    if (inst.options.dragMaxTouches > 0 && ev.touches.length > inst.options.dragMaxTouches) {
      return;
    }
    switch (ev.eventType) {
      case EVENT_START:
        triggered = false;
        break;
      case EVENT_MOVE:
        if (ev.distance < inst.options.dragMinDistance && cur.name != name) {
          return;
        }
        var startCenter = cur.startEvent.center;
        if (cur.name != name) {
          cur.name = name;
          if (inst.options.dragDistanceCorrection && ev.distance > 0) {
            var factor = Math.abs(inst.options.dragMinDistance / ev.distance);
            startCenter.pageX += ev.deltaX * factor;
            startCenter.pageY += ev.deltaY * factor;
            startCenter.clientX += ev.deltaX * factor;
            startCenter.clientY += ev.deltaY * factor;
            ev = Detection.extendEventData(ev);
          }
        }
        if (cur.lastEvent.dragLockToAxis || inst.options.dragLockToAxis && inst.options.dragLockMinDistance <= ev.distance) {
          ev.dragLockToAxis = true;
        }
        var lastDirection = cur.lastEvent.direction;
        if (ev.dragLockToAxis && lastDirection !== ev.direction) {
          if (Utils.isVertical(lastDirection)) {
            ev.direction = ev.deltaY < 0 ? DIRECTION_UP : DIRECTION_DOWN;
          } else {
            ev.direction = ev.deltaX < 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;
          }
        }
        if (!triggered) {
          inst.trigger(name + "start", ev);
          triggered = true;
        }
        inst.trigger(name, ev);
        inst.trigger(name + ev.direction, ev);
        var isVertical2 = Utils.isVertical(ev.direction);
        if (inst.options.dragBlockVertical && isVertical2 || inst.options.dragBlockHorizontal && !isVertical2) {
          ev.preventDefault();
        }
        break;
      case EVENT_RELEASE:
        if (triggered && ev.changedLength <= inst.options.dragMaxTouches) {
          inst.trigger(name + "end", ev);
          triggered = false;
        }
        break;
      case EVENT_END:
        triggered = false;
        break;
    }
  }
  GestureDetector.gestures.Drag = {
    name,
    index: 50,
    handler: dragGesture,
    defaults: {
      /**
       * minimal movement that have to be made before the drag event gets triggered
       * @property dragMinDistance
       * @type {Number}
       * @default 10
       */
      dragMinDistance: 10,
      /**
       * Set dragDistanceCorrection to true to make the starting point of the drag
       * be calculated from where the drag was triggered, not from where the touch started.
       * Useful to avoid a jerk-starting drag, which can make fine-adjustments
       * through dragging difficult, and be visually unappealing.
       * @property dragDistanceCorrection
       * @type {Boolean}
       * @default true
       */
      dragDistanceCorrection: true,
      /**
       * set 0 for unlimited, but this can conflict with transform
       * @property dragMaxTouches
       * @type {Number}
       * @default 1
       */
      dragMaxTouches: 1,
      /**
       * prevent default browser behavior when dragging occurs
       * be careful with it, it makes the element a blocking element
       * when you are using the drag gesture, it is a good practice to set this true
       * @property dragBlockHorizontal
       * @type {Boolean}
       * @default false
       */
      dragBlockHorizontal: false,
      /**
       * same as `dragBlockHorizontal`, but for vertical movement
       * @property dragBlockVertical
       * @type {Boolean}
       * @default false
       */
      dragBlockVertical: false,
      /**
       * dragLockToAxis keeps the drag gesture on the axis that it started on,
       * It disallows vertical directions if the initial direction was horizontal, and vice versa.
       * @property dragLockToAxis
       * @type {Boolean}
       * @default false
       */
      dragLockToAxis: false,
      /**
       * drag lock only kicks in when distance > dragLockMinDistance
       * This way, locking occurs only when the distance has become large enough to reliably determine the direction
       * @property dragLockMinDistance
       * @type {Number}
       * @default 25
       */
      dragLockMinDistance: 25
    }
  };
})("drag");
GestureDetector.gestures.Gesture = {
  name: "gesture",
  index: 1337,
  handler: function releaseGesture(ev, inst) {
    inst.trigger(this.name, ev);
  }
};
(function(name) {
  var timer;
  function holdGesture(ev, inst) {
    var options = inst.options, current = Detection.current;
    switch (ev.eventType) {
      case EVENT_START:
        clearTimeout(timer);
        current.name = name;
        timer = setTimeout(function() {
          if (current && current.name == name) {
            inst.trigger(name, ev);
          }
        }, options.holdTimeout);
        break;
      case EVENT_MOVE:
        if (ev.distance > options.holdThreshold) {
          clearTimeout(timer);
        }
        break;
      case EVENT_RELEASE:
        clearTimeout(timer);
        break;
    }
  }
  GestureDetector.gestures.Hold = {
    name,
    index: 10,
    defaults: {
      /**
       * @property holdTimeout
       * @type {Number}
       * @default 500
       */
      holdTimeout: 500,
      /**
       * movement allowed while holding
       * @property holdThreshold
       * @type {Number}
       * @default 2
       */
      holdThreshold: 2
    },
    handler: holdGesture
  };
})("hold");
GestureDetector.gestures.Release = {
  name: "release",
  index: Infinity,
  handler: function releaseGesture2(ev, inst) {
    if (ev.eventType == EVENT_RELEASE) {
      inst.trigger(this.name, ev);
    }
  }
};
GestureDetector.gestures.Swipe = {
  name: "swipe",
  index: 40,
  defaults: {
    /**
     * @property swipeMinTouches
     * @type {Number}
     * @default 1
     */
    swipeMinTouches: 1,
    /**
     * @property swipeMaxTouches
     * @type {Number}
     * @default 1
     */
    swipeMaxTouches: 1,
    /**
     * horizontal swipe velocity
     * @property swipeVelocityX
     * @type {Number}
     * @default 0.6
     */
    swipeVelocityX: 0.6,
    /**
     * vertical swipe velocity
     * @property swipeVelocityY
     * @type {Number}
     * @default 0.6
     */
    swipeVelocityY: 0.6
  },
  handler: function swipeGesture(ev, inst) {
    if (ev.eventType == EVENT_RELEASE) {
      var touches = ev.touches.length, options = inst.options;
      if (touches < options.swipeMinTouches || touches > options.swipeMaxTouches) {
        return;
      }
      if (ev.velocityX > options.swipeVelocityX || ev.velocityY > options.swipeVelocityY) {
        inst.trigger(this.name, ev);
        inst.trigger(this.name + ev.direction, ev);
      }
    }
  }
};
(function(name) {
  var hasMoved = false;
  function tapGesture(ev, inst) {
    var options = inst.options, current = Detection.current, prev = Detection.previous, sincePrev, didDoubleTap;
    switch (ev.eventType) {
      case EVENT_START:
        hasMoved = false;
        break;
      case EVENT_MOVE:
        hasMoved = hasMoved || ev.distance > options.tapMaxDistance;
        break;
      case EVENT_END:
        if (!Utils.inStr(ev.srcEvent.type, "cancel") && ev.deltaTime < options.tapMaxTime && !hasMoved) {
          sincePrev = prev && prev.lastEvent && ev.timeStamp - prev.lastEvent.timeStamp;
          didDoubleTap = false;
          if (prev && prev.name == name && (sincePrev && sincePrev < options.doubleTapInterval) && ev.distance < options.doubleTapDistance) {
            inst.trigger("doubletap", ev);
            didDoubleTap = true;
          }
          if (!didDoubleTap || options.tapAlways) {
            current.name = name;
            inst.trigger(current.name, ev);
          }
        }
        break;
    }
  }
  GestureDetector.gestures.Tap = {
    name,
    index: 100,
    handler: tapGesture,
    defaults: {
      /**
       * max time of a tap, this is for the slow tappers
       * @property tapMaxTime
       * @type {Number}
       * @default 250
       */
      tapMaxTime: 250,
      /**
       * max distance of movement of a tap, this is for the slow tappers
       * @property tapMaxDistance
       * @type {Number}
       * @default 10
       */
      tapMaxDistance: 10,
      /**
       * always trigger the `tap` event, even while double-tapping
       * @property tapAlways
       * @type {Boolean}
       * @default true
       */
      tapAlways: true,
      /**
       * max distance between two taps
       * @property doubleTapDistance
       * @type {Number}
       * @default 20
       */
      doubleTapDistance: 20,
      /**
       * max time between two taps
       * @property doubleTapInterval
       * @type {Number}
       * @default 300
       */
      doubleTapInterval: 300
    }
  };
})("tap");
GestureDetector.gestures.Touch = {
  name: "touch",
  index: -Infinity,
  defaults: {
    /**
     * call preventDefault at touchstart, and makes the element blocking by disabling the scrolling of the page,
     * but it improves gestures like transforming and dragging.
     * be careful with using this, it can be very annoying for users to be stuck on the page
     * @property preventDefault
     * @type {Boolean}
     * @default false
     */
    preventDefault: false,
    /**
     * disable mouse events, so only touch (or pen!) input triggers events
     * @property preventMouse
     * @type {Boolean}
     * @default false
     */
    preventMouse: false
  },
  handler: function touchGesture(ev, inst) {
    if (inst.options.preventMouse && ev.pointerType == POINTER_MOUSE) {
      ev.stopDetect();
      return;
    }
    if (inst.options.preventDefault) {
      ev.preventDefault();
    }
    if (ev.eventType == EVENT_TOUCH) {
      inst.trigger("touch", ev);
    }
  }
};
(function(name) {
  var triggered = false;
  function transformGesture(ev, inst) {
    switch (ev.eventType) {
      case EVENT_START:
        triggered = false;
        break;
      case EVENT_MOVE:
        if (ev.touches.length < 2) {
          return;
        }
        var scaleThreshold = Math.abs(1 - ev.scale);
        var rotationThreshold = Math.abs(ev.rotation);
        if (scaleThreshold < inst.options.transformMinScale && rotationThreshold < inst.options.transformMinRotation) {
          return;
        }
        Detection.current.name = name;
        if (!triggered) {
          inst.trigger(name + "start", ev);
          triggered = true;
        }
        inst.trigger(name, ev);
        if (rotationThreshold > inst.options.transformMinRotation) {
          inst.trigger("rotate", ev);
        }
        if (scaleThreshold > inst.options.transformMinScale) {
          inst.trigger("pinch", ev);
          inst.trigger("pinch" + (ev.scale < 1 ? "in" : "out"), ev);
        }
        break;
      case EVENT_RELEASE:
        if (triggered && ev.changedLength < 2) {
          inst.trigger(name + "end", ev);
          triggered = false;
        }
        break;
    }
  }
  GestureDetector.gestures.Transform = {
    name,
    index: 45,
    defaults: {
      /**
       * minimal scale factor, no scale is 1, zoomin is to 0 and zoomout until higher then 1
       * @property transformMinScale
       * @type {Number}
       * @default 0.01
       */
      transformMinScale: 0.01,
      /**
       * rotation in degrees
       * @property transformMinRotation
       * @type {Number}
       * @default 1
       */
      transformMinRotation: 1
    },
    handler: transformGesture
  };
})("transform");
var gesture_detector_default = GestureDetector;

// node_modules/onsenui/esm/ons/content-ready.js
var readyMap;
var queueMap;
function isContentReady(element) {
  if (element.childNodes.length > 0) {
    setContentReady(element);
  }
  return readyMap.has(element);
}
function setContentReady(element) {
  readyMap.set(element, true);
}
function addCallback(element, fn) {
  if (!queueMap.has(element)) {
    queueMap.set(element, []);
  }
  queueMap.get(element).push(fn);
}
function consumeQueue(element) {
  const callbacks = queueMap.get(element, []) || [];
  queueMap.delete(element);
  callbacks.forEach((callback) => callback());
}
function contentReady(element, fn = () => {
}) {
  if (readyMap === void 0) {
    readyMap = /* @__PURE__ */ new WeakMap();
    queueMap = /* @__PURE__ */ new WeakMap();
  }
  addCallback(element, fn);
  if (isContentReady(element)) {
    consumeQueue(element);
    return;
  }
  const observer = new MutationObserver((changes) => {
    setContentReady(element);
    consumeQueue(element);
  });
  observer.observe(element, { childList: true, characterData: true });
  setImmediate(() => {
    setContentReady(element);
    consumeQueue(element);
  });
}

// node_modules/onsenui/esm/ons/internal/toast-queue.js
var ToastQueue = class {
  constructor() {
    this.queue = [];
  }
  add(fn, promise) {
    this.queue.push(fn);
    if (this.queue.length === 1) {
      setImmediate(this.queue[0]);
    }
    promise.then(() => {
      this.queue.shift();
      if (this.queue.length > 0) {
        setTimeout(this.queue[0], 1e3 / 30);
      }
    });
  }
};
var toast_queue_default = new ToastQueue();

// node_modules/onsenui/esm/ons/notification.js
var _setAttributes = (element, options) => {
  ["id", "class", "animation"].forEach((a) => Object.prototype.hasOwnProperty.call(options, a) && element.setAttribute(a, options[a]));
  if (options.modifier) {
    util_default.addModifier(element, options.modifier);
  }
};
var _normalizeArguments = (message, options = {}, defaults = {}) => {
  options = { ...options };
  typeof message === "string" ? options.message = message : options = message;
  if (!options || !options.message && !options.messageHTML) {
    util_default.throw("Notifications must contain a message");
  }
  if (Object.prototype.hasOwnProperty.call(options, "buttonLabels") || Object.prototype.hasOwnProperty.call(options, "buttonLabel")) {
    options.buttonLabels = options.buttonLabels || options.buttonLabel;
    if (!Array.isArray(options.buttonLabels)) {
      options.buttonLabels = [options.buttonLabels || ""];
    }
  }
  return util_default.extend({
    compile: (param) => param,
    callback: (param) => param,
    animation: "default",
    cancelable: false,
    primaryButtonIndex: (options.buttonLabels || defaults.buttonLabels || []).length - 1
  }, defaults, options);
};
var notification = {};
notification._createAlertDialog = (...params) => new Promise((resolve) => {
  const options = _normalizeArguments(...params);
  util_default.checkMissingImport("AlertDialog", "AlertDialogButton");
  let inputString = "";
  if (options.isPrompt) {
    inputString = `
      <input
        class="text-input text-input--underbar"
        type="${options.inputType || "text"}"
        placeholder="${options.placeholder || ""}"
        value="${options.defaultValue || ""}"
        style="width: 100%; margin-top: 10px;"
      />
    `;
  }
  let buttons = "";
  options.buttonLabels.forEach((label, index) => {
    buttons += `
      <ons-alert-dialog-button
        class="
          ${index === options.primaryButtonIndex ? " alert-dialog-button--primal" : ""}
          ${options.buttonLabels.length <= 2 ? " alert-dialog-button--rowfooter" : ""}
        "
        style="position: relative;">
        ${label}
      </ons-alert-dialog-button>
    `;
  });
  let el2 = {};
  const _destroyDialog = () => {
    if (el2.dialog.onDialogCancel) {
      el2.dialog.removeEventListener("dialogcancel", el2.dialog.onDialogCancel);
    }
    Object.keys(el2).forEach((key) => delete el2[key]);
    el2 = null;
    if (options.destroy instanceof Function) {
      options.destroy();
    }
  };
  el2.dialog = document.createElement("ons-alert-dialog");
  el2.dialog.innerHTML = `
    <div class="alert-dialog-mask"
      style="
        ${options.maskColor ? "background-color: " + options.maskColor : ""}
      "></div>
    <div class="alert-dialog">
      <div class="alert-dialog-container">
        <div class="alert-dialog-title">
          ${options.title || ""}
        </div>
        <div class="alert-dialog-content">
          ${options.message || options.messageHTML}
          ${inputString}
        </div>
        <div class="
          alert-dialog-footer
          ${options.buttonLabels.length <= 2 ? " alert-dialog-footer--rowfooter" : ""}
        ">
          ${buttons}
        </div>
      </div>
    </div>
  `;
  contentReady(el2.dialog);
  _setAttributes(el2.dialog, options);
  if (options.isPrompt) {
    el2.input = el2.dialog.querySelector(".text-input");
    if (options.submitOnEnter) {
      el2.input.onkeypress = (event) => {
        if (event.keyCode === 13) {
          el2.dialog.hide().then(() => {
            if (el2) {
              const resolveValue = el2.input.value;
              _destroyDialog();
              options.callback(resolveValue);
              resolve(resolveValue);
            }
          });
        }
      };
    }
  }
  el2.footer = el2.dialog.querySelector(".alert-dialog-footer");
  util_default.arrayFrom(el2.dialog.querySelectorAll(".alert-dialog-button")).forEach((buttonElement, index) => {
    buttonElement.onclick = () => {
      el2.dialog.hide().then(() => {
        if (el2) {
          let resolveValue = index;
          if (options.isPrompt) {
            resolveValue = index === options.primaryButtonIndex ? el2.input.value : null;
          }
          el2.dialog.remove();
          _destroyDialog();
          options.callback(resolveValue);
          resolve(resolveValue);
        }
      });
    };
    el2.footer.appendChild(buttonElement);
  });
  if (options.cancelable) {
    el2.dialog.cancelable = true;
    el2.dialog.onDialogCancel = () => {
      setImmediate(() => {
        el2.dialog.remove();
        _destroyDialog();
      });
      const resolveValue = options.isPrompt ? null : -1;
      options.callback(resolveValue);
      resolve(resolveValue);
    };
    el2.dialog.addEventListener("dialogcancel", el2.dialog.onDialogCancel, false);
  }
  document.body.appendChild(el2.dialog);
  options.compile(el2.dialog);
  setImmediate(() => {
    el2.dialog.show().then(() => {
      if (el2.input && options.isPrompt && options.autofocus) {
        const strLength = el2.input.value.length;
        el2.input.focus();
        if (el2.input.type && ["text", "search", "url", "tel", "password"].includes(el2.input.type)) {
          el2.input.setSelectionRange(strLength, strLength);
        }
      }
    });
  });
});
notification.alert = (message, options) => notification._createAlertDialog(message, options, {
  buttonLabels: ["OK"],
  title: "Alert"
});
notification.confirm = (message, options) => notification._createAlertDialog(message, options, {
  buttonLabels: ["Cancel", "OK"],
  title: "Confirm"
});
notification.prompt = (message, options) => notification._createAlertDialog(message, options, {
  buttonLabels: ["OK"],
  title: "Alert",
  isPrompt: true,
  autofocus: true,
  submitOnEnter: true
});
notification.toast = (message, options) => {
  const promise = new Promise((resolve) => {
    util_default.checkMissingImport("Toast");
    options = _normalizeArguments(message, options, {
      timeout: 0,
      force: false
    });
    let toast = util_default.createElement(`
      <ons-toast>
        ${options.message}
        ${options.buttonLabels ? `<button>${options.buttonLabels[0]}</button>` : ""}
      </ons-toast>
    `);
    _setAttributes(toast, options);
    const originalHide = toast.hide.bind(toast);
    const finish = (value) => {
      if (toast) {
        originalHide().then(() => {
          if (toast) {
            toast.remove();
            toast = null;
            options.callback(value);
            resolve(value);
          }
        });
      }
    };
    if (options.buttonLabels) {
      util_default.findChild(toast._toast, "button").onclick = () => finish(0);
    }
    toast.hide = () => finish(-1);
    document.body.appendChild(toast);
    options.compile(toast);
    const show = () => {
      toast.parentElement && toast.show(options).then(() => {
        if (options.timeout) {
          setTimeout(() => finish(-1), options.timeout);
        }
      });
    };
    setImmediate(() => options.force ? show() : toast_queue_default.add(show, promise));
  });
  return promise;
};
var notification_default = notification;

// node_modules/onsenui/esm/ons/action-sheet.js
var checkOptions = (options) => {
  const err = (prop, type = "Function") => util_default.throw(`"options.${prop}" must be an instance of ${type}`);
  const hasOwnProperty = (prop) => Object.hasOwnProperty.call(options, prop);
  const instanceOf = (prop, type = Function) => options[prop] instanceof type;
  const b = "buttons", cb = "callback", c = "compile", d = "destroy";
  (!hasOwnProperty(b) || !instanceOf(b, Array)) && err(b, "Array");
  hasOwnProperty(cb) && !instanceOf(cb) && err(cb);
  hasOwnProperty(c) && !instanceOf(c) && err(c);
  hasOwnProperty(d) && !instanceOf(d) && err(d);
};
var action_sheet_default = (options = {}) => new Promise((resolve) => {
  util_default.checkMissingImport("ActionSheet");
  checkOptions(options);
  let actionSheet = util_default.createElement(`
    <ons-action-sheet
      ${options.title ? `title="${options.title}"` : ""}
      ${options.cancelable ? "cancelable" : ""}
      ${options.modifier ? `modifier="${options.modifier}"` : ""}
      ${options.maskColor ? `mask-color="${options.maskColor}"` : ""}
      ${options.id ? `id="${options.id}"` : ""}
      ${options.class ? `class="${options.class}"` : ""}
    >
      <div class="action-sheet"></div>
    </ons-action-sheet>
  `);
  const finish = (event, index = -1) => {
    if (actionSheet) {
      options.destroy && options.destroy(actionSheet);
      actionSheet.removeEventListener("dialogcancel", finish, false);
      actionSheet.remove();
      actionSheet = null;
      options.callback && options.callback(index);
      resolve(index);
    }
  };
  actionSheet.addEventListener("dialogcancel", finish, false);
  const buttons = document.createDocumentFragment();
  options.buttons.forEach((item, index) => {
    const buttonOptions = typeof item === "string" ? { label: item } : { ...item };
    if (options.destructive === index) {
      buttonOptions.modifier = (buttonOptions.modifier || "") + " destructive";
    }
    const button = util_default.createElement(`
      <ons-action-sheet-button
        ${buttonOptions.icon ? `icon="${buttonOptions.icon}"` : ""}
        ${buttonOptions.modifier ? `modifier="${buttonOptions.modifier}"` : ""}
      >
        ${buttonOptions.label}
      </ons-action-sheet-button>
    `);
    button.onclick = (event) => actionSheet.hide().then(() => finish(event, index));
    buttons.appendChild(button);
  });
  util_default.findChild(actionSheet, ".action-sheet").appendChild(buttons);
  document.body.appendChild(actionSheet);
  options.compile && options.compile(el.dialog);
  setImmediate(() => actionSheet.show({
    animation: options.animation,
    animationOptions: options.animationOptions
  }));
});

// node_modules/onsenui/esm/ons/orientation.js
var create = () => {
  const obj = {
    /**
     * @event change
     * @description
     *   [en]Fired when the device orientation changes.[/en]
     *   [ja]デバイスのオリエンテーションが変化した際に発火します。[/ja]
     * @param {Object} event
     *   [en]Event object.[/en]
     *   [ja]イベントオブジェクトです。[/ja]
     * @param {Boolean} event.isPortrait
     *   [en]Will be true if the current orientation is portrait mode.[/en]
     *   [ja]現在のオリエンテーションがportraitの場合にtrueを返します。[/ja]
     */
    /**
     * @method on
     * @signature on(eventName, listener)
     * @description
     *   [en]Add an event listener.[/en]
     *   [ja]イベントリスナーを追加します。[/ja]
     * @param {String} eventName
     *   [en]Name of the event.[/en]
     *   [ja]イベント名を指定します。[/ja]
     * @param {Function} listener
     *   [en]Function to execute when the event is triggered.[/en]
     *   [ja]このイベントが発火された際に呼び出される関数オブジェクトを指定します。[/ja]
     */
    /**
     * @method once
     * @signature once(eventName, listener)
     * @description
     *  [en]Add an event listener that's only triggered once.[/en]
     *  [ja]一度だけ呼び出されるイベントリスナーを追加します。[/ja]
     * @param {String} eventName
     *   [en]Name of the event.[/en]
     *   [ja]イベント名を指定します。[/ja]
     * @param {Function} listener
     *   [en]Function to execute when the event is triggered.[/en]
     *   [ja]イベントが発火した際に呼び出される関数オブジェクトを指定します。[/ja]
     */
    /**
     * @method off
     * @signature off(eventName, [listener])
     * @description
     *  [en]Remove an event listener. If the listener is not specified all listeners for the event type will be removed.[/en]
     *  [ja]イベントリスナーを削除します。もしイベントリスナーを指定しなかった場合には、そのイベントに紐づく全てのイベントリスナーが削除されます。[/ja]
     * @param {String} eventName
     *   [en]Name of the event.[/en]
     *   [ja]イベント名を指定します。[/ja]
     * @param {Function} listener
     *   [en]Function to execute when the event is triggered.[/en]
     *   [ja]削除するイベントリスナーを指定します。[/ja]
     */
    // actual implementation to detect if whether current screen is portrait or not
    _isPortrait: false,
    /**
     * @method isPortrait
     * @signature isPortrait()
     * @return {Boolean}
     *   [en]Will be true if the current orientation is portrait mode.[/en]
     *   [ja]オリエンテーションがportraitモードの場合にtrueになります。[/ja]
     * @description
     *   [en]Returns whether the current screen orientation is portrait or not.[/en]
     *   [ja]オリエンテーションがportraitモードかどうかを返します。[/ja]
     */
    isPortrait: function() {
      return this._isPortrait();
    },
    /**
     * @method isLandscape
     * @signature isLandscape()
     * @return {Boolean}
     *   [en]Will be true if the current orientation is landscape mode.[/en]
     *   [ja]オリエンテーションがlandscapeモードの場合にtrueになります。[/ja]
     * @description
     *   [en]Returns whether the current screen orientation is landscape or not.[/en]
     *   [ja]オリエンテーションがlandscapeモードかどうかを返します。[/ja]
     */
    isLandscape: function() {
      return !this.isPortrait();
    },
    _init: function() {
      document.addEventListener("DOMContentLoaded", this._onDOMContentLoaded.bind(this), false);
      if ("orientation" in window) {
        window.addEventListener("orientationchange", this._onOrientationChange.bind(this), false);
      } else {
        window.addEventListener("resize", this._onResize.bind(this), false);
      }
      this._isPortrait = function() {
        return window.innerHeight > window.innerWidth;
      };
      return this;
    },
    _onDOMContentLoaded: function() {
      this._installIsPortraitImplementation();
      this.emit("change", { isPortrait: this.isPortrait() });
    },
    _installIsPortraitImplementation: function() {
      const isPortrait = window.innerWidth < window.innerHeight;
      if (!("orientation" in window)) {
        this._isPortrait = function() {
          return window.innerHeight > window.innerWidth;
        };
      } else if (window.orientation % 180 === 0) {
        this._isPortrait = function() {
          return Math.abs(window.orientation % 180) === 0 ? isPortrait : !isPortrait;
        };
      } else {
        this._isPortrait = function() {
          return Math.abs(window.orientation % 180) === 90 ? isPortrait : !isPortrait;
        };
      }
    },
    _onOrientationChange: function() {
      const isPortrait = this._isPortrait();
      let nIter = 0;
      const interval = setInterval(() => {
        nIter++;
        const w = window.innerWidth;
        const h = window.innerHeight;
        if (isPortrait && w <= h || !isPortrait && w >= h) {
          this.emit("change", { isPortrait });
          clearInterval(interval);
        } else if (nIter === 50) {
          this.emit("change", { isPortrait });
          clearInterval(interval);
        }
      }, 20);
    },
    // Run on not mobile browser.
    _onResize: function() {
      this.emit("change", { isPortrait: this.isPortrait() });
    }
  };
  microevent_default.mixin(obj);
  return obj;
};
var orientation_default = create()._init();

// node_modules/onsenui/esm/ons/modifier.js
var modifier_default = {
  /**
   * @method add
   * @signature add(element, modifier [, modifier])
   * @description
   *   [en]Add the specified modifiers to the element if they are not already included.[/en]
   *   [ja][/ja]
   * @param {HTMLElement} element
   *   [en]Target element.[/en]
   *   [ja][/ja]
   * @param {String} modifier
   *   [en]Name of the modifier.[/en]
   *   [ja][/ja]
   */
  add: (element, ...modifiers) => modifiers.forEach((modifier) => util_default.addModifier(element, modifier)),
  /**
   * @method remove
   * @signature remove(element, modifier [, modifier])
   * @description
   *   [en]Remove the specified modifiers from the element if they are included.[/en]
   *   [ja][/ja]
   * @param {HTMLElement} element
   *   [en]Target element.[/en]
   *   [ja][/ja]
   * @param {String} modifier
   *   [en]Name of the modifier.[/en]
   *   [ja][/ja]
   */
  remove: (element, ...modifiers) => modifiers.forEach((modifier) => util_default.removeModifier(element, modifier)),
  /**
   * @method contains
   * @signature contains(element, modifier)
   * @description
   *   [en]Check whether the specified modifier is included in the element.[/en]
   *   [ja][/ja]
   * @param {HTMLElement} element
   *   [en]Target element.[/en]
   *   [ja][/ja]
   * @param {String} modifier
   *   [en]Name of the modifier.[/en]
   *   [ja][/ja]
   * @return {Boolean}
   *   [en]`true` when the specified modifier is found in the element's `modifier` attribute. `false` otherwise.[/en]
   *   [ja][/ja]
   */
  contains: util_default.hasModifier,
  /**
   * @method toggle
   * @signature toggle(element, modifier [, force])
   * @description
   *   [en]Toggle the specified modifier.[/en]
   *   [ja][/ja]
   * @param {HTMLElement} element
   *   [en]Target element.[/en]
   *   [ja][/ja]
   * @param {String} modifier
   *   [en]Name of the modifier.[/en]
   *   [ja][/ja]
   * @param {String} force
   *   [en]If it evaluates to true, add specified modifier value, and if it evaluates to false, remove it.[/en]
   *   [ja][/ja]
   */
  toggle: util_default.toggleModifier
};

// node_modules/onsenui/esm/ons/software-keyboard.js
var softwareKeyboard = new microevent_default();
softwareKeyboard._visible = false;
var onShow = () => {
  softwareKeyboard._visible = true;
  softwareKeyboard.emit("show");
};
var onHide = () => {
  softwareKeyboard._visible = false;
  softwareKeyboard.emit("hide");
};
var bindEvents = () => {
  if (typeof Keyboard !== "undefined") {
    Keyboard.onshow = onShow;
    Keyboard.onhide = onHide;
    softwareKeyboard.emit("init", { visible: Keyboard.isVisible });
    return true;
  } else if (typeof cordova.plugins !== "undefined" && typeof cordova.plugins.Keyboard !== "undefined") {
    window.addEventListener("native.keyboardshow", onShow);
    window.addEventListener("native.keyboardhide", onHide);
    softwareKeyboard.emit("init", { visible: cordova.plugins.Keyboard.isVisible });
    return true;
  }
  return false;
};
var noPluginError = () => {
  util_default.warn("ons-keyboard: Cordova Keyboard plugin is not present.");
};
document.addEventListener("deviceready", () => {
  if (!bindEvents()) {
    if (document.querySelector("[ons-keyboard-active]") || document.querySelector("[ons-keyboard-inactive]")) {
      noPluginError();
    }
    softwareKeyboard.on = noPluginError;
  }
});
var software_keyboard_default = softwareKeyboard;

// node_modules/onsenui/esm/ons/doorlock.js
var generateId = function() {
  let i = 0;
  return function() {
    return i++;
  };
}();
var DoorLock = class {
  constructor(options = {}) {
    this._lockList = [];
    this._waitList = [];
    this._log = options.log || function() {
    };
  }
  /**
   * Register a lock.
   *
   * @return {Function} Callback for unlocking.
   */
  lock() {
    const unlock = () => {
      this._unlock(unlock);
    };
    unlock.id = generateId();
    this._lockList.push(unlock);
    this._log("lock: " + unlock.id);
    return unlock;
  }
  _unlock(fn) {
    const index = this._lockList.indexOf(fn);
    if (index === -1) {
      throw new Error("This function is not registered in the lock list.");
    }
    this._lockList.splice(index, 1);
    this._log("unlock: " + fn.id);
    this._tryToFreeWaitList();
  }
  _tryToFreeWaitList() {
    while (!this.isLocked() && this._waitList.length > 0) {
      this._waitList.shift()();
    }
  }
  /**
   * Register a callback for waiting unlocked door.
   *
   * @params {Function} callback Callback on unlocking the door completely.
   */
  waitUnlock(callback) {
    if (!(callback instanceof Function)) {
      throw new Error("The callback param must be a function.");
    }
    if (this.isLocked()) {
      this._waitList.push(callback);
    } else {
      callback();
    }
  }
  /**
   * @return {Boolean}
   */
  isLocked() {
    return this._lockList.length > 0;
  }
};

// node_modules/onsenui/esm/ons/page-loader.js
function loadPage({ page, parent, params = {} }, done, error3) {
  internal_default.getPageHTMLAsync(page).then((html) => {
    const pageElement = util_default.createElement(html);
    parent.appendChild(pageElement);
    done(pageElement);
  }).catch((e) => error3(e));
}
function unloadPage(element) {
  if (element._destroy instanceof Function) {
    element._destroy();
  } else {
    element.remove();
  }
}
var PageLoader = class {
  /**
   * @param {Function} [fn] Returns an object that has "element" property and "unload" function.
   */
  constructor(loader, unloader) {
    this._loader = loader instanceof Function ? loader : loadPage;
    this._unloader = unloader instanceof Function ? unloader : unloadPage;
  }
  /**
   * Set internal loader implementation.
   */
  set internalLoader(fn) {
    if (!(fn instanceof Function)) {
      throw Error("First parameter must be an instance of Function");
    }
    this._loader = fn;
  }
  get internalLoader() {
    return this._loader;
  }
  /**
   * @param {any} options.page
   * @param {Element} options.parent A location to load page.
   * @param {Object} [options.params] Extra parameters for ons-page.
   * @param {Function} done Take an object that has "element" property and "unload" function.
   * @param {Function} error Function called when there is an error.
   */
  load({ page, parent, params = {} }, done, error3) {
    this._loader({ page, parent, params }, (pageElement) => {
      if (!(pageElement instanceof Element)) {
        throw Error("pageElement must be an instance of Element.");
      }
      done(pageElement);
    }, error3);
  }
  unload(pageElement) {
    if (!(pageElement instanceof Element)) {
      throw Error("pageElement must be an instance of Element.");
    }
    this._unloader(pageElement);
  }
};
var defaultPageLoader = new PageLoader();
var instantPageLoader = new PageLoader(
  function({ page, parent, params = {} }, done) {
    const element = util_default.createElement(page.trim());
    parent.appendChild(element);
    done(element);
  },
  unloadPage
);

// node_modules/onsenui/esm/ons/index.js
var ons = {
  animit: animit_default,
  defaultPageLoader,
  elements: elements_default,
  GestureDetector: gesture_detector_default,
  modifier: modifier_default,
  notification: notification_default,
  orientation: orientation_default,
  pageAttributeExpression: page_attribute_expression_default,
  PageLoader,
  platform: platform_default,
  softwareKeyboard: software_keyboard_default,
  _autoStyle: autostyle_default,
  _internal: internal_default,
  _readyLock: new DoorLock(),
  _util: util_default
};
ons.platform.select((window.location.search.match(/platform=([\w-]+)/) || [])[1]);
waitDeviceReady();
var readyError = (after) => util_default.throw(`This method must be called ${after ? "after" : "before"} ons.isReady() is true`);
ons.isReady = () => {
  return !ons._readyLock.isLocked();
};
ons.isWebView = ons.platform.isWebView;
ons.ready = (callback) => {
  if (ons.isReady()) {
    callback();
  } else {
    ons._readyLock.waitUnlock(callback);
  }
};
ons.setDefaultDeviceBackButtonListener = function(listener) {
  if (!ons.isReady()) {
    readyError(true);
  }
  ons._defaultDeviceBackButtonHandler.setListener(listener);
};
ons.disableDeviceBackButtonHandler = function() {
  if (!ons.isReady()) {
    readyError(true);
  }
  internal_default.dbbDispatcher.disable();
};
ons.enableDeviceBackButtonHandler = function() {
  if (!ons.isReady()) {
    readyError(true);
  }
  internal_default.dbbDispatcher.enable();
};
ons.fireDeviceBackButtonEvent = function() {
  internal_default.dbbDispatcher.fireDeviceBackButtonEvent();
};
ons.enableAutoStatusBarFill = () => {
  if (ons.isReady()) {
    readyError(false);
  }
  internal_default.config.autoStatusBarFill = true;
};
ons.disableAutoStatusBarFill = () => {
  if (ons.isReady()) {
    readyError(false);
  }
  internal_default.config.autoStatusBarFill = false;
};
ons.mockStatusBar = () => {
  if (ons.isReady()) {
    readyError(false);
  }
  const mock = () => {
    if (!document.body.children[0] || !document.body.children[0].classList.contains("ons-status-bar-mock")) {
      const android = platform_default.isAndroid(), i = (i2) => `<i class="${i2.split("-")[0]} ${i2}"></i>`;
      const left = android ? `${i("zmdi-twitter")} ${i("zmdi-google-play")}` : `No SIM ${i("fa-wifi")}`, center = android ? "" : "12:28 PM", right = android ? `${i("zmdi-network")} ${i("zmdi-wifi")} ${i("zmdi-battery")} 12:28 PM` : `80% ${i("fa-battery-three-quarters")}`;
      document.body.insertBefore(util_default.createElement(
        `<div class="ons-status-bar-mock ${android ? "android" : "ios"}"><div>${left}</div><div>${center}</div><div>${right}</div></div>`
      ), document.body.firstChild);
    }
  };
  document.body ? mock() : internal_default.waitDOMContentLoaded(mock);
};
ons.disableAnimations = () => {
  internal_default.config.animationsDisabled = true;
};
ons.enableAnimations = () => {
  internal_default.config.animationsDisabled = false;
};
ons._disableWarnings = () => {
  internal_default.config.warningsDisabled = true;
};
ons._enableWarnings = () => {
  internal_default.config.warningsDisabled = false;
};
ons.disableAutoStyling = autostyle_default.disable;
ons.enableAutoStyling = autostyle_default.enable;
ons.disableIconAutoPrefix = () => {
  util_default.checkMissingImport("Icon");
  elements_default.Icon.setAutoPrefix(false);
};
ons.forcePlatformStyling = (newPlatform) => {
  ons.enableAutoStyling();
  ons.platform.select(newPlatform || "ios");
  ons._util.arrayFrom(document.querySelectorAll("*")).forEach(function(element) {
    if (element.tagName.toLowerCase() === "ons-if") {
      element._platformUpdate();
    } else if (element.tagName.match(/^ons-/i)) {
      autostyle_default.prepare(element, true);
      if (element.tagName.toLowerCase() === "ons-tabbar") {
        element._updatePosition();
      }
    }
  });
};
ons.preload = function(templates = []) {
  return Promise.all((templates instanceof Array ? templates : [templates]).map((template) => {
    if (typeof template !== "string") {
      util_default.throw("Expected string arguments but got " + typeof template);
    }
    return internal_default.getTemplateHTMLAsync(template);
  }));
};
ons.createElement = (template, options = {}) => {
  template = template.trim();
  const create2 = (html) => {
    const element = ons._util.createElement(html);
    element.remove();
    if (options.append) {
      const target = options.append instanceof HTMLElement ? options.append : document.body;
      target.insertBefore(element, options.insertBefore || null);
      options.link instanceof Function && options.link(element);
    }
    return element;
  };
  return template.charAt(0) === "<" ? create2(template) : internal_default.getPageHTMLAsync(template).then(create2);
};
ons.createPopover = ons.createDialog = ons.createAlertDialog = (template, options = {}) => ons.createElement(template, { append: true, ...options });
ons.openActionSheet = action_sheet_default;
ons.resolveLoadingPlaceholder = (page, link) => {
  const elements = ons._util.arrayFrom(window.document.querySelectorAll("[ons-loading-placeholder]"));
  if (elements.length === 0) {
    util_default.throw("No ons-loading-placeholder exists");
  }
  elements.filter((element) => !element.getAttribute("page")).forEach((element) => {
    element.setAttribute("ons-loading-placeholder", page);
    ons._resolveLoadingPlaceholder(element, page, link);
  });
};
ons._setupLoadingPlaceHolders = function() {
  ons.ready(() => {
    const elements = ons._util.arrayFrom(window.document.querySelectorAll("[ons-loading-placeholder]"));
    elements.forEach((element) => {
      const page = element.getAttribute("ons-loading-placeholder");
      if (typeof page === "string") {
        ons._resolveLoadingPlaceholder(element, page);
      }
    });
  });
};
ons._resolveLoadingPlaceholder = function(parent, page, link = (el2, done) => done()) {
  page && ons.createElement(page).then((element) => {
    element.style.display = "none";
    parent.appendChild(element);
    link(element, () => {
      while (parent.firstChild && parent.firstChild !== element) {
        parent.removeChild(parent.firstChild);
      }
      element.style.display = "";
    });
  }).catch((error3) => Promise.reject("Unabled to resolve placeholder: " + error3));
};
function waitDeviceReady() {
  const unlockDeviceReady = ons._readyLock.lock();
  window.addEventListener("DOMContentLoaded", () => {
    if (ons.isWebView()) {
      window.document.addEventListener("deviceready", unlockDeviceReady, { once: true });
    } else {
      unlockDeviceReady();
    }
  }, { once: true });
}
var getCS = "currentScript" in document ? () => document.currentScript : () => document.scripts[document.scripts.length - 1];
ons.getScriptPage = () => getCS() && /ons-page/i.test(getCS().parentElement.tagName) && getCS().parentElement || null;
var ons_default = ons;

// node_modules/onsenui/esm/index.js
setup(ons_default);
var esm_default = ons_default;

export {
  elements_default,
  styler_default,
  platform_default,
  AnimatorFactory,
  autostyle_default,
  ModifierUtil,
  device_back_button_dispatcher_default,
  internal_default,
  util_default,
  contentReady,
  animit_default,
  gesture_detector_default,
  orientation_default,
  DoorLock,
  PageLoader,
  defaultPageLoader,
  instantPageLoader,
  esm_default
};
/*! Bundled license information:

onsenui/esm/polyfills/MutationObserver@0.7.22/MutationObserver.js:
  (**
   * @license
   * Copyright (c) 2014 The Polymer Project Authors. All rights reserved.
   * This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
   * The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
   * The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
   * Code distributed by Google as part of the polymer project is also
   * subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
   *)
*/
//# sourceMappingURL=chunk-DLGUDK6Q.js.map
